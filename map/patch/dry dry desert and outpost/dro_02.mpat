%Merlee changes
%The weaker spells occur more often to give you some purpose to buy them
%you might get the cheap one Right before a boss fight so that you can strategically get attack increases


%two separarate tables that look very similar
%# of spells
@ $ByteTable_802475DC
{
	1E0C0400
}

%costs
@ $ByteTable_802475E0
{
	3C281400
}

@ $Script_MakeEntities
{
		Call  MakeEntity  		( .Entity:Signpost ~Vec4d:Sign 80000000 )
		Call	 AssignScript ( $Script_SignPostA )
		Call  MakeEntity  		( .Entity:Signpost ~Vec4d:Sign2 80000000 )
		Call	 AssignScript ( $Script_SignPostB )
		0:  Call  MakeItemEntity    ( .Item:Letter08 ~Vec3d:Item80243BD0 .ItemSpawnMode:Fixed_NeverVanish *GF_DRO02_Item_Letter08 )
   24:  Call  MakeEntity        ( .Entity:HiddenPanel ~Vec4d:Entity80243BF4 ~Model:1_yane 80000000 )
   4C:  Call  AssignPanelFlag   ( *GF_DRO02_HiddenPanel )
   5C:  Return
   64:  End
}


#new:Script $Script_SignPostA
{
		%Potential future feature: show the current spell info on the sign
	0:  Call     DisablePlayerInput 	( .True )
		Call	 $Function_GetPlayerDataByte ( *Var0 00000289 )
		Call	 $Function_GetPlayerDataByte ( *Var1 0000028A )
		Call	 $Function_GetPlayerDataByte ( *Var2 0000028B )
		Call	 $Function_GetPlayerDataByte ( *Var3 0000028D ) %spell turns remaining is a short for some reason
		If *Var0 == 1			
			Call	 SetMessageString ( $Attack 0 )
		Else
			Call	 SetMessageString ( $Defense 0 )
		EndIf
		Call	 SetMessageValue ( *Var1 1 )
		Call	 SetMessageValue ( *Var2 2 )
		Call	 SetMessageValue ( *Var3 3 )
		Call     ShowMessageAtScreenPos 	( $SpellInfo 000000A0 00000028 )
	8:  Call     DisablePlayerInput 	( .False )
   38:  Return
   40: End
}

#new:Script $Script_SignPostB
{
		%Potential future feature: show the current spell info on the sign
	0:  Call     DisablePlayerInput 	( .True )
		Call	 $Function_GetPlayerDataByte ( *Var0 00000289 )
		Call	 $Function_GetPlayerDataByte ( *Var1 0000028A )
		Call	 $Function_GetPlayerDataByte ( *Var2 0000028B )
		Call	 $Function_GetPlayerDataByte ( *Var3 0000028D ) %spell turns remaining is a short for some reason
		If *Var0 == 1			
			Call	 SetMessageString ( $Attack 0 )
		Else
			Call	 SetMessageString ( $Defense 0 )
		EndIf
		Call	 SetMessageValue ( *Var1 1 )
		Call	 SetMessageValue ( *Var2 2 )
		Call	 SetMessageValue ( *Var3 3 )
		Call     ShowMessageAtScreenPos 	( $SpellInfo2 000000A0 00000028 )
	8:  Call     DisablePlayerInput 	( .False )
   38:  Return
   40: End
}

#new:String $Attack
{
[Color:20]Attack[Color:0A][END]
}

#new:String $Defense
{
[Color:23]Defense[Color:0A][END]
}

#new:String $SpellInfo
{
	[DelayOff][Style Sign]       -Spell Information-[BR]
	More expensive spells will give[BR]
	you more activations, but they[BR]
	will occur less frequently.[BR]
	[Wait][NEXT]
	Petit Course     - 1 per 4 turns[BR]
	Ordinary Course - 1 per 6 turns[BR]
	Special Course   - 1 per 10 turns[BR]
	[Wait][NEXT]
	Petit Course   - 4 activations[BR]
	Ordinary Course - 12 activations[BR]
	Special Course - 30 activations[BR]
	[Wait][NEXT]
	The spell alternates between[BR]
	attack and defense. If you end[BR]
	battle with exactly 2 turns[BR]
	until activation...[BR]
	[Wait][NEXT]
	...the coin or star point spells[BR]
	will activate if the defense[BR]
	or attack spell is next,[BR]
	respectively.[BR]
	[DelayOn][Wait][END] 
}

#new:String $SpellInfo2
{
	[DelayOff][Style Sign]-Current Spell Information-[BR]
	[Wait][NEXT]
	Spell type:                  [Var 0][BR]
	Spell uses left:                   [Var 1][BR]
	Spell frequency:              1 / [Var 2][BR]
	Turns until next:                 [Var 3][BR]
	[DelayOn][Wait][END] 
}


%Original:
%	20 spells for 50 coins	(1 spell for 2.5 coins)
%	10 spells for 20 coins  (1 spell for 2 coins)
%	5 spells for 5 coins    (1 spell for 1 coin)

%Now:
%	30 spells for 60 coins (1 per 10 turns)
%	12 spells for 40 coins (1 per 6 turns)
%	4 spells for 20 coins (1 per 4 turns)

%	^ for these values, (cost / spell) * (1 / frequency) is the same, but thats basically an arbitrary value

@ $Function_80241394
{
    0:  ADDIU     SP, SP, FFE0
    4:  SW        S2, 18 (SP)
    8:  COPY      S2, A0
    C:  SW        RA, 1C (SP)
   10:  SW        S1, 14 (SP)
   14:  SW        S0, 10 (SP)
   18:  LW        S0, C (S2)
   1C:  LW        A1, 0 (S0)
   20:  JAL       ~Func:get_variable
   24:  ADDIU     S0, S0, 4
   28:  LA        S1, 8010F290
		COPY	  T0, V0						%keep this for later
   30:  LTBU      A1, V0 ($ByteTable_802475E0)
   3C:  LH        V1, C (S1)
   40:  LW        S0, 0 (S0)
   44:  LTBU      A2, V0 ($ByteTable_802475DC)
   50:  LHU       A0, C (S1)
   54:  SLT       V1, V1, A1
   58:  BEQ       V1, R0, .o70
   5C:  ANDI      V0, A1, FF
   60:  COPY      A0, S2
   64:  COPY      A1, S0
   68:  BEQ       R0, R0, .o108
   6C:  LI        A2, 1
        .o70
   70:  SUBU      V0, A0, V0		%Subtract cost
   74:  SH        V0, C (S1)		%Store to coins
   78:  LB        V0, 28A (S1)		%Spell uses
   7C:  ANDI      V1, A2, FF		%take spell uses from table
   80:  SLT       V0, V0, V1		%
   %84:  BNEL      V0, R0, .o8C		%get rid of this
   88:  SB        A2, 28A (S1)
        .o8C
		%calculate frequency (Special = 0, Normal = 1, Petit = 2)
		ORI		  T1, R0, 8
		SRLV  	  T0, T1, T0			%Divide by 2 ^ T0 (so T0 is either 2,4,8)
		ADDIU	  T0, T0, 2				%add 2 (so T0 is either 4,6,10)
		SB		  T0, 28B (S1)	
		%now set up the initial values
   %8C:  JAL       ~Func:rand_int		
   %90:  LI        A0, 2
   %94:  ADDIU     V0, V0, 1
		%Store turn frequency to the turns remaining address
   98:  SH        T0, 28C (S1)
		%The base game code is overcomplicated
		%It really just had to be a random 0-3 then add 1
   %9C:  JAL       ~Func:rand_int
   %A0:  LI        A0, 3
		%ADDIU	  V0, V0, 1
		%but I don't want rng, so set the first spell to atk
		ADDIU	  V0, R0, 1
		SB        V0, 289 (S1)
		COPY      A0, S2
		COPY      A1, S0
		CLEAR     A2				%Second variable checks if you have enough money
		/%
   9C:  JAL       ~Func:rand_int
   A0:  LI        A0, 3
   A4:  COPY      V1, V0			%V1 = 0,1,2
   A8:  LI        A0, 1
   AC:  BEQ       V1, A0, .oE4		%if V1 = 1, skip to oE4 (set V0 to 2
   B0:  SLTI      V0, V1, 2
   B4:  BEQ       V0, R0, .oCC		%if V0 is not < 2, skip to oCC (either go to oEC to set V0 to 3 or go to oF4 and set V0 to 4, if neither, set V0 to 0)
   B8:  LI        V0, 2
   BC:  BEQL      V1, R0, .oFC
   C0:  SB        A0, 289 (S1)
   C4:  BEQ       R0, R0, .o100
   C8:  COPY      A0, S2
        .oCC
   CC:  BEQ       V1, V0, .oEC
   D0:  LI        V0, 3
   D4:  BEQ       V1, V0, .oF4
   D8:  COPY      A0, S2
   DC:  BEQ       R0, R0, .o104
   E0:  COPY      A1, S0
        .oE4
   E4:  BEQ       R0, R0, .oF8
   E8:  LI        V0, 2
        .oEC
   EC:  BEQ       R0, R0, .oF8
   F0:  LI        V0, 3
        .oF4
   F4:  LI        V0, 4
        .oF8
   F8:  SB        V0, 289 (S1)
        .oFC
   FC:  COPY      A0, S2
        .o100
  100:  COPY      A1, S0
        .o104
  104:  CLEAR     A2
        %/
		.o108		
  108:  JAL       ~Func:set_variable
  10C:  NOP
  110:  LW        RA, 1C (SP)
  114:  LW        S2, 18 (SP)
  118:  LW        S1, 14 (SP)
  11C:  LW        S0, 10 (SP)
  120:  LI        V0, 2
  124:  JR        RA
  128:  ADDIU     SP, SP, 20
}

@ $Script_802482F8
{
[214]  Call  ShowChoice        ( $Choices ) % Special Course 50 coins Ordinary Course 20 coins P ...
}

#new:String $Choices
{
	[Style Choice pos=50,70 size=230,60]
	[StartChoice]
	[Option 0]Special Course    60 coins[BR]
	[Option 1]Ordinary Course  40 coins[BR]
	[Option 2]Petit Course       20 coins[BR]
	[EndChoice cancel=3][End]
}





% ====================================================
% Chuck Quizmo will continue asking questions so long
% as another is available.
%
% The existing script is modified by adding two labels
% for flow control and new code to check for the next
% question after the player recieves a star piece.
% ====================================================

@ $Script_80246520
{
	0:  If  *GB_CompletedQuizzes  >  0000003F 
   10:  	Set  *Var[0]  00000000 
   20:  	Return
   28:  EndIf
   30:  Call     GetPlayerPos 	( *Array[1] *Array[2] *Array[3] )
   48:  Call     NpcFacePlayer 	( .Npc:Self 00000010 )
   5C:  If  *GB_CompletedQuizzes  ==  0000003F 
   6C:  	Call     SpeakToPlayer 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000A ) % Kaaaa-wiiiizzz! It's everyone's favorite quizmaste ...
   8C:  Else
   94:  	If  *GF_Met_ChuckQuizmo  ==  00000001 
   A4:  		Call     SpeakToPlayer 	( .Npc:Self 00AF0004 00AF0001 00000000 00080009 ) % Kaaaa-wiiiizzz! It's everyone's favorite quizmaste ...
   C4:  	Else
   CC:  		Call     SpeakToPlayer 	( .Npc:Self 00AF0004 00AF0001 00000000 00080008 ) % Kaaaa-wiiiizzz! Chuck Quizmo's the name, and quizz ...
   EC:  		Set  *GF_Met_ChuckQuizmo  00000001 
   FC:  	EndIf
  104:  EndIf
  10C:  Call     ShowChoice  	( 001E000D ) % Yes No 
  11C:  If  *Var[0]  ==  00000001 
  12C:  	Call     ContinueSpeech 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000C ) % Uh, oh. Not up to it, huh? Maybe another time! Wel ...
  14C:  	ExecWait $Script_80244ED4 
  158:  	Set  *Var[0]  00000000 
  168:  	Return
  170:  EndIf
  178:  Set  *GF_Quizmo_TakingQuiz  00000001 
  188:  Call     $Function_80240418 ( )
  194:  Call     $Function_8024072C ( )
  1A0:  Exec     $Script_80244F84 
  1AC:  Call     DisablePartnerAI 	( 00000000 )
  1BC:  Call     SetNpcFlagBits ( .Npc:Partner 00000200 .False )
  1D4:  Call     SetNpcFlagBits ( 0000000A 00000200 .False )
  1EC:  Call     SetNpcFlagBits ( .Npc:Partner 00000148 .True )
  204:  Call     SetNpcFlagBits ( 0000000A 00000100 .True )
  21C:  Call     SetNpcAnimation 	( .Npc:Partner 00000106 )
  230:  Exec     $Script_802456AC *Var[1] 
  240:  Call     ContinueSpeech 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000B ) % Then let's go to the question!
  260:  Call     PlaySound   	( 00000089 )
  270:  Loop     
  27C:  	DoesScriptExist *Var[1] *Var[0] 
  28C:  	If  *Var[0]  ==  00000000 
  29C:  		BreakLoop
  2A4:  	EndIf
  2AC:  	Wait     00000001 
  2B8:  EndLoop
  2C0:  Call     $Function_80240A70 ( )
  2CC:  Loop     00000005 
  2D8:  	Call     GetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
  2F0:  	Add  *Var[1]  00000001 
  300:  	Call     SetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
  318:  	Wait     00000002 
  324:  EndLoop
    	Label	0	% new label for multiple questions
  32C:  Set  *Var[0]  002C0000 
  33C:  Add  *Var[0]  *GB_CompletedQuizzes 
  34C:  Call     SpeakToPlayer 	( .Npc:Self 00AF0005 00AF0006 00000000 *Var[0] ) % variable string ID
  36C:  Call     SetPlayerAnimation 	( 00010028 )
  37C:  Set  *Var[0]  002D0000 
  38C:  Add  *Var[0]  *GB_CompletedQuizzes 
  39C:  Call     PlaySound   	( 0000008E )
  3AC:  Call     ShowChoice  	( *Var[0] ) % variable string ID
  3BC:  Kill     *Var[1] 
  3C8:  Call     802D62B8 ( 0000008E )
  3D8:  Exec     $Script_80245720 
  3E4:  Wait     0000000F 
  3F0:  Call     PlaySound   	( 0000008D )
  400:  Call     $Function_80240D70 ( *Var[0] )
  410:  Set  *Array[4]  00000000 
%  420:  Call     $Function_80241364 ( ) %-- draw O/X ...but leaks memory if we loop, will crash after too many questions
  42C:  Wait     00000028 
  438:  Call     $Function_802409EC ( )
  444:  Thread
  44C:  	Wait     0000006E 
  458:  	Call     CloseChoice ( )
  464:  	Set  *Array[4]  00000000 
  474:  EndThread
  47C:  If  *Var[0]  ==  00000001 
  48C:  	Call     SetNpcAnimation 	( 0000000A 00AF0007 )
  4A0:  	Set  *Array[4]  00000001 
  4B0:  	Thread
  4B8:  		Call     $Function_80240D3C ( 00000001 )
  4C8:  		Wait     00000006 
  4D4:  		Wait     00000006 
  4E0:  		Wait     00000006 
  4EC:  		Call     $Function_80240D3C ( 00000002 )
  4FC:  	EndThread
  504:  	Thread
  50C:  		Call     PlaySound   	( 0000021C )
  51C:  		Wait     00000006 
  528:  		Call     PlaySound   	( 0000021C )
  538:  		Wait     00000006 
  544:  		Call     PlaySound   	( 0000021C )
  554:  		Wait     00000006 
  560:  		Call     PlaySound   	( 0000021C )
  570:  	EndThread
  578:  	Call     PlaySound   	( 0000008A )
  588:  	Call     $Function_80240E08 ( )
  594:  	Thread
  59C:  		Wait     0000000F 
  5A8:  		Call     GetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
  5C0:  		Add  *Var[1]  00000032 
  5D0:  		Call     $Function_80240F80 ( 00000000 00000000 00000053 *Var[0] *Var[2] )
  5F0:  		Call     PlayEffect  	( ~FX:Steam:Ring *Var[0] *Var[1] *Var[2] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  634:  		Call     PlayEffect  	( 00000044 00000004 *Var[0] *Var[1] *Var[2] 00000001 0000003C 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  678:  		Wait     0000000F 
  684:  		Add  *Var[1]  FFFFFFFD 
  694:  		Call     $Function_80240F80 ( 00000000 00000000 0000003A *Var[0] *Var[2] )
  6B4:  		Call     PlayEffect  	( ~FX:Steam:Ring *Var[0] *Var[1] *Var[2] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  6F8:  		Call     PlayEffect  	( 00000044 00000004 *Var[0] *Var[1] *Var[2] 00000001 0000003C 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  73C:  		Wait     0000000F 
  748:  		Add  *Var[1]  0000001E 
  758:  		Call     $Function_80240F80 ( 00000000 00000000 0000005D *Var[0] *Var[2] )
  778:  		Call     PlayEffect  	( ~FX:Steam:Ring *Var[0] *Var[1] *Var[2] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  7BC:  		Call     PlayEffect  	( 00000044 00000004 *Var[0] *Var[1] *Var[2] 00000001 0000003C 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  800:  		Wait     0000000F 
  80C:  	EndThread
  814:  	Wait     00000014 
  820:  	Exec     $Script_802463C0 *Var[1] 
  830:  	Add  *GB_CompletedQuizzes  00000001 
  840:  	If  *GB_CompletedQuizzes  >  0000003F 
  850:  		Call     ContinueSpeech 	( .Npc:Self FFFFFFFF FFFFFFFF 00000000 00080010 ) % Correct!! Congratulations! This is my last prize!  ...
  870:  		Call     SetNpcAnimation 	( 0000000A 00AF0006 )
  884:  		Loop     
  890:  			DoesScriptExist *Var[1] *Var[0] 
  8A0:  			If  *Var[0]  ==  00000000 
  8B0:  				BreakLoop
  8B8:  			EndIf
  8C0:  			Wait     00000001 
  8CC:  		EndLoop
  8D4:  		Call     SetNpcAnimation 	( 0000000A 00AF0005 )
  8E8:  		Set  *Var[0]  0000015C 
  8F8:  		Set  *Var[1]  00000003 
  908:  		ExecWait $Script_80244DE4 
  914:  		Call     AddStarPieces 	( 00000001 )
  924:  		Call     $Function_80240D3C ( 0000000F )
  934:  		Call     $Function_80240DF0 ( )
  940:  		Call     SetMessageValue 	( *GB_CompletedQuizzes 00000000 )
  954:  		Call     SpeakToPlayer 	( .Npc:Self 00AF0004 00AF0001 00000000 00080011 ) % You've managed to correctly answer all  questions. ...
  974:  	Else
  97C:  		Call     ContinueSpeech 	( .Npc:Self FFFFFFFF FFFFFFFF 00000000 0008000E ) % Correct! Congratulations! Here's your Star Piece!
  99C:  		Call     SetNpcAnimation 	( 0000000A 00AF0006 )
  9B0:  		Loop     
  9BC:  			DoesScriptExist *Var[1] *Var[0] 
  9CC:  			If  *Var[0]  ==  00000000 
  9DC:  				BreakLoop
  9E4:  			EndIf
  9EC:  			Wait     00000001 
  9F8:  		EndLoop
  A00:  		Call     SetNpcAnimation 	( 0000000A 00AF0005 )
  A14:  		Set  *Var[0]  0000015C 
  A24:  		Set  *Var[1]  00000001 
  A34:  		ExecWait $Script_80244DE4 
  A40:  		Call     AddStarPieces 	( 00000001 )
  A50:  		Call     $Function_80240D3C ( 0000000F )
  A60:  		Call     $Function_80240DF0 ( )
  A6C:  		Call     SetMessageValue 	( *GB_CompletedQuizzes 00000000 )
  A80:  		If  *GB_CompletedQuizzes  ==  00000001 
  A90:  			Call     SetMessageString 	( 8014C294 00000001 )
  AA4:  		Else
  AAC:  			Call     SetMessageString 	( 8014C290 00000001 )
  AC0:  		EndIf
  AC8:  		Call     SpeakToPlayer 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000F ) % You've correctly answered  question so far. Good l ...
    		% ====================================================
			% new: multiple quizzes can be completed at a time
				Wait	10`
				Call	$Function_IsNextQuestionAvailable ( )
				If  *Var[0]  ==  00000000 
					Call     SpeakToPlayer	( .Npc:Self 00AF0004 00AF0001 00000000 0008004A ) % Looks like that's it for now ...
					Set      *Var[0] 00000001 
					Goto	1
				EndIf
				Call     SpeakToPlayer		( .Npc:Self 00AF0004 00AF0001 00000000 00080049 ) % But we're not done yet ...
				Call     ShowChoice			( 001E000D ) % Yes No 
				If	*Var[0] ==  00000001 
					Call     ContinueSpeech 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000C ) % Uh, oh. Not up to it, huh? Maybe another time! Wel ...
					Set      *Var[0] 00000001 
					Goto	1
				EndIf
				Call     ContinueSpeech 	( .Npc:Self 00AF0004 00AF0001 00000000 0008000B ) % Then let's go to the question!
				Thread
					Call     $Function_80240F80 ( *Array[1] *Array[3] 0000006C *Var[0] *Var[1] )
					SetF     *Var[2] *Array[1] 
					AddF     *Var[2] *Var[0] 
					SetF     *Var[3] *Array[3] 
					AddF     *Var[3] *Var[1] 
					Call     SetNpcAnimation 	( .Npc:Partner 00000102 )
					Call     NpcMoveTo   		( .Npc:Partner *Var[2] *Var[3] 00000028 )
					Call     SetNpcAnimation 	( .Npc:Partner 00000106 )
					Call     NpcFacePlayer 		( .Npc:Partner 00000000 )
				EndThread
				Call     $Function_80240F80 ( *Array[1] *Array[3] 00000053 *Var[0] *Var[1] )
				SetF     *Var[3] *Var[0] 
				SetF     *Var[4] *Var[1] 
				AddF     *Var[3] *Array[1]
				AddF     *Var[4] *Array[3]
				Call     PlayerMoveTo 	( *Var[3] *Var[4] 40` )
				Loop     00000005 
					Call     GetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
					Add      *Var[1] 00000001 
					Call     SetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
					Wait     00000002 
				EndLoop
				Goto	0
		%/new
		% ====================================================
  AE8:  	EndIf
  AF0:  	Set  *Var[0]  00000001 
  B00:  Else
  B08:  	Call     SetNpcAnimation 	( 0000000A 00AF0009 )
  B1C:  	Set  *Array[4]  00000002 
  B2C:  	Call     PlaySound   	( 0000021D )
  B3C:  	Call     PlaySound   	( 0000008B )
  B4C:  	Exec     $Script_80246470 *Var[1] 
  B5C:  	Call     GetPlayerPos 	( *Var[2] *Var[3] *Var[4] )
  B74:  	Call     PlayEffect  	( 0000002B 00000000 *Var[2] *Var[3] *Var[4] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
  BB8:  	Call     ContinueSpeech 	( .Npc:Self FFFFFFFF FFFFFFFF 00000000 0008000D ) % Oops! Tough luck, pal! Wrong answer! Better luck n ...
  BD8:  	Call     SetNpcAnimation 	( 0000000A 00AF000A )
  BEC:  	Loop     
  BF8:  		DoesScriptExist *Var[1] *Var[0] 
  C08:  		If  *Var[0]  ==  00000000 
  C18:  			BreakLoop
  C20:  		EndIf
  C28:  		Wait     00000001 
  C34:  	EndLoop
  C3C:  	Set  *Var[0]  00000000 
  C4C:  EndIf
    	Label	1	% new label for multiple questions
  C54:  Call     $Function_80240D70 ( FFFFFFFF )
  C64:  Call     EnablePartnerAI 	( )
  C70:  Thread
  C78:  	Wait     0000001E 
  C84:  	Call     PlaySound   	( 0000008F )
  C94:  EndThread
  C9C:  Thread
  CA4:  	Wait     0000002D 
  CB0:  	Call     802D62B8 ( 00000089 )
  CC0:  EndThread
  CC8:  Call     $Function_80240E24 ( )
  CD4:  Call     $Function_80240C88 ( )
  CE0:  ExecWait $Script_80244ED4 
  CEC:  Exec     $Script_8024521C 
  CF8:  Call     $Function_80240878 ( )
  D04:  Call     $Function_8024042C ( )
  D10:  Set  *GF_Quizmo_TakingQuiz  00000000 
  D20:  Return
  D28:  End
}

% Since we never loaded the O/X icon, don't try to free it.
@ $Function_80240C88[9C]
{
	NOP
}

#new:Function $Function_IsNextQuestionAvailable
{
	PUSH	RA, S0, S1
	DADDU	S1, A0, R0
	DADDU	A0, R0, R0
	LIO		A1, *GB_CompletedQuizzes
	JAL		~Func:get_variable
	RESERVED
	DADDU	A0, R0, R0
	DADDU	S0, V0, R0
	LIO		A1, *GB_StoryProgress
	JAL		~Func:get_variable
	RESERVED
	DADDU	A1, V0, R0
	LIA		A0, $QuizRequirements
    .FindStoryProgress
	LW		V0, 0 (A0)
	SLT		V0, A1, V0
	BNE		V0, R0, .CompareQuizIndex
	NOP
	BEQ		R0, R0, .FindStoryProgress
	ADDIU	A0, A0, 8
	.CompareQuizIndex
	LW		V0, 4 (A0)
	SLT		V0, S0, V0
	SW		V0, 84 (S1)
	.Done
	POP		RA, S0, S1
	JR		RA
	ADDIU	V0, R0, 2
}
  
@ $QuizRequirements
{
% if (story progress) < (col 1), the player can complete up to (col 2) quizzes
FFFFFF94 00000000 % < chapter 1 start
FFFFFFB4 00000006 % < chapter 2 start
FFFFFFCA 0000000C % < chapter 3 start
FFFFFFF2 00000012 % < chapter 4 start
00000006 0000001A % < chapter 5 start
00000027 00000022 % < chapter 6 start
0000003A 0000002A % < chapter 7 start
00000058 00000034 % < chapter 8 start
0000005F 00000040 % end game
00000060 00000040 % all
}

@ $QuizAnswers
{
01010200 01000200 01020001 01020200 
02010202 01000201 00010201 00020100 
02000102 00000001 00020002 02010001
02020102 02010102 00020102 01000201
}