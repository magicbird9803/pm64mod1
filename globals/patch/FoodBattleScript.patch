%I have basically infinite globals space so I'll just put food scripts here lol
#export:Script:Battle $Script_SpecialFood
{
	If *GB_FileCodeMode == 14`
		%Make these items not useless
		Switch *Var1
			CaseOR == .Item:StrangeLeaf
			CaseOR == .Item:DualityShake
				Call	 $Function_SetArbitraryByte ( 00000000 $ItemCostReductionData[2] )
				Call	 $Function_SetArbitraryByte ( 00000000 $ItemCostReductionData[3] )		
			EndCaseGroup				
			Default
				Call	 $Function_SetArbitraryByte ( 00000002 $ItemCostReductionData[2] )
				Call	 $Function_SetArbitraryByte ( 00000000 $ItemCostReductionData[3] )		
		EndSwitch
	EndIf
	Set *FoodByteAux 0`
	Switch *Var[1]
		Case == .Item:DarkTea
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0
			Set *Var1 0
			Set *Var2 50
			Call	 $Function_DebuffEffectUnified ( )
			Call 	$Function_GetPlayerDataByte ( *Var5 2` )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					If *Var5 > 100`
						Set *Var5 100`
					EndIf
				Case == 1`
					If *Var5 > 75`
						Set *Var5 75`
					EndIf
				Default
					If *Var5 > 50`
						Set *Var5 50`
					EndIf
			EndSwitch			
			Mul *Var5 -1`
			Call     $Function_HPHeal ( *Var5 )			
			Mul *Var5 -1`
			Add *Var5 9`
			Div *Var5 10`						
			Mul *Var5 -1`
			Call 	 $Function_SetDefdown 	( *Var5 00000003 )
		Case == .Item:DarkPop
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0
			Set *Var1 0
			Set *Var2 50
			Call	 $Function_DebuffEffectUnified ( )
			Call 	$Function_GetPlayerDataByte ( *Var5 5` )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					%double effect
					%so take away 3/4 instead of 1/2
					Set *Var6 *Var5
					Mul *Var6 3`
					Div *Var6 4`
					Set *Var5 *Var6
				Case == 1`
					%1.5x effect
					%take away 1/2, then take away 1/4
					%take away 5/8
					Set *Var6 *Var5
					Mul *Var6 5`
					Div *Var6 8`
					Set *Var5 *Var6
				Default
					Div *Var5 2`				
			EndSwitch				
			Mul *Var5 -1`
			%negative 
			Call 	$Function_FPHeal ( *Var5 )					
			Mul *Var5 -1`
			%now positive
			Add *Var5 9`
			Div *Var5 10`						
			Call 	 $Function_SetSaver 	( *Var5 00000004 )		
		Case == .Item:DarkLeaf	%Dark leaf
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0
			Set *Var1 0
			Set *Var2 50
			Call	 $Function_DebuffEffectUnified ( )
			Call 	 $Function_SetChill 	( 00000003 00000003 )
			Call 	 $Function_SetDefdown 	( FFFFFFFD 00000003 )
		Case == .Item:DarkShroom	%Dark shroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0`
			Set *Var1 0`
			Set *Var2 0`
			Call	 $Function_DebuffEffectUnified ( )
			Call 	 $Function_SetChill 	( FFFFFFFD 00000003 )
			Call 	 $Function_SetDefdown 	( 00000003 00000003 )
		Case == .Item:GoldenMeal
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )
			Call	$Function_ResetStatus ( )
			Call 	 $Function_SetSaver 	( 00000002 00000005 )	
			Label 	31
			Call 	RemoveItem ( .Item:GoldenMeal *Var5 )
			If *Var5 != FFFFFFFF
				Goto 31
			EndIf					
		Case == .Item:DualityShake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )			
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Add *Var5 5`
			Set *Var0 0`
			Set *Var1 0`
			Set *Var2 0`
			Call	 $Function_DebuffEffectUnified ( )	
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					%double effect
					%so it basically does nothing :P
					Call 	$Function_DualityShake ( )
					Call 	$Function_DualityShake ( )
					Mul 	*DelayedHealAmount -1`
					Mul 	*DelayedHealAmount -1`
				Case == 1`
					%1.5x effect
					%so basically nullifies everything
					Call 	$Function_DualityShakeNull ( )
					Mul 	*DelayedHealAmount 0`
					%Apply duality to other effects
					%duality x 1.5 does nothing
					Call 	$Function_ResetStatus ( )
					%reset hustle
					Call  $Function_SetArbitraryByte ( 00000000 800DC0FB )	%800DC070 + 8B
					%reset other statuses
					Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
					Add *Var5 210
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )		%debuff (210)
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )		%electric
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )		%stone
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )		%partner stun (not on mario)
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
					Add *Var5 1
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )		%vanish
					Add *Var5 1	
					Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
				Default
					Call 	$Function_DualityShake ( )
					Mul 	*DelayedHealAmount -1`
					%Apply duality to other effects
					%Hustle -> Stop
					Call  $Function_GetArbitraryByte ( *Var5 800DC0FB )	%800DC070 + 8B
					If *Var5 != 0`
						Call  $Function_SetArbitraryByte ( 00000000 800DC0FB )	%800DC070 + 8B
						Set *FoodByteAux 1`
						Goto PostDuality
					EndIf
					%Electrified (not if zap tap!) -> Paralyzed
					Call  $Function_CheckBadge ( .Item:ZapTap *Var5 )
					If *Var5 == 0`
						Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
						Add *Var5 212
						Call  $Function_GetArbitraryByte ( *Var6 *Var5 )
						If *Var6 != 0`
							Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
							Add *Var5 2`
							Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
							Set *FoodByteAux 2`
							Goto PostDuality
						EndIf
					EndIf
					%Vanish <-> Dizzy
					Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
					Add *Var5 218
					Call  $Function_GetArbitraryByte ( *Var6 *Var5 )
					If *Var6 != 0`	%yes vanish
						Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
						Add *Var5 210
						Call  $Function_GetArbitraryByte ( *Var7 *Var5 )						
						If *Var7 == 4`
							%Do nothing
						Else
							%apply dizzy, remove vanish
							Set *FoodByteAux 3`
							Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
							Add *Var5 218
							Call  $Function_SetArbitraryByte ( 00000000 *Var5 )
						EndIf
					Else
						Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
						Add *Var5 210
						Call  $Function_GetArbitraryByte ( *Var7 *Var5 )						
						If *Var7 == 4`
							%apply vanish, remove dizzy
							Call $Function_CureStatus ( )
							Call $Function_ApplyVanish ( )
						EndIf
					EndIf
					%Poison -> (+3 recovery per turn)
					Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
					Add *Var5 210
					Call  $Function_GetArbitraryByte ( *Var7 *Var5 )						
					If *Var7 == 9`
						%remove poison
						Call $Function_CureStatus ( )
						If *DelayedHealAmount <= 0
							Set *DelayedHealAmount 3
							Add *DelayedHealTurns 3  %the stuff that makes it actually work is in fivehealth.patch
						Else
							%the strength of the effect will be of the stronger one
							If  *DelayedHealAmount < 3`
								%Step 1: calculate remaining total heal
								Set *Var[F] *DelayedHealAmount
								Mul *Var[F] *DelayedHealTurns						
								%*Var[F] = total heal amount
								%
								%Step 2:
								%set values to the stronger ones						
								Set *DelayedHealAmount 3
								Set *DelayedHealTurns 3  %add the normal healing too
								Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
								If *VarE == 1`
									Add *DelayedHealTurns 1
								EndIf
								If *VarE == 2`
									Add *DelayedHealTurns 3
								EndIf
								%
								%Step 3: apply bonus healing
								%Bonus turns = varF / amount
								Div *VarF *DelayedHealAmount
								Add *DelayedHealTurns *VarF
								If *VarF < 1`
									Add *DelayedHealTurns 1
								EndIf
							Else
								If *DelayedHealAmount == 3
									%equal => amount += (turncount)
									%Simple
									Add *DelayedHealTurns 3
									Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
									If *VarE == 1`
										Add *DelayedHealTurns 1
									EndIf
									If *VarE == 2`
										Add *DelayedHealTurns 3
									EndIf
								Else
									%Step 1: calculate new heal
									Set *Var[F] 3
									Mul *Var[F] 3
									Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
									If *VarE == 1`
										Add *Var[F] 3
									EndIf
									If *VarF == 2`
										Add *Var[F] 9
									EndIf							
									%*Var[F] = total heal amount
									%
									%Step 2: apply bonus healing
									%Bonus turns = varF / amount
									Div *VarF *DelayedHealAmount
									Add *DelayedHealTurns *VarF
									If *VarF < 1`
										Add *DelayedHealTurns 1
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
					%Shrink -> (+2 atk for ? turns, use recovery stack logic)
					Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
					Add *Var5 210
					Call  $Function_GetArbitraryByte ( *Var7 *Var5 )						
					Add *Var5 1
					Call  $Function_GetArbitraryByte ( *Var6 *Var5 )
					If *Var7 == A
						%remove shrink
						Call $Function_CureStatus ( )
						Call 	 $Function_SetChill 	( FFFFFFFE *Var6 )
					EndIf					
			EndSwitch			
			Label PostDuality
		Case == .Item:StrawberryPop
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000003 00000003 )	
		Case == .Item:DryJuice
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )											
			Call 	$Function_SetSaver ( 00000001 00000003 )
		Case == .Item:StrangeTea
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			%complicated
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					%Do it twice. Easy
					Call 	$Function_GetPlayerDataByte ( *Var5 2` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 3` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					EndIf
					Call 	$Function_GetPlayerDataByte ( *Var5 5` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 6` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					EndIf
					%
					Call 	$Function_GetPlayerDataByte ( *Var5 2` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 3` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					EndIf
					Call 	$Function_GetPlayerDataByte ( *Var5 5` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 6` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					EndIf						
				Case == 1`
					%Not so easy
					%do step 1, then do half of step 2
					Call 	$Function_GetPlayerDataByte ( *Var5 2` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 3` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					EndIf
					Call 	$Function_GetPlayerDataByte ( *Var5 5` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 6` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					EndIf
					%
					%Do step 2 by half
					%
					Call 	$Function_GetPlayerDataByte ( *Var5 2` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Set *Var7 *Var6
						Div *Var6 4`
						Sub *Var7 *Var6
						Set *Var6 *Var7
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Set *Var7 *Var6
						Div *Var7 2`
						Add *Var6 *Var7
						Call 	$Function_GetPlayerDataByte ( *Var7 3` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					EndIf
					Call 	$Function_GetPlayerDataByte ( *Var5 5` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Set *Var7 *Var6
						Div *Var6 4`
						Sub *Var7 *Var6
						Set *Var6 *Var7
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Set *Var7 *Var6
						Div *Var7 2`
						Add *Var6 *Var7
						Call 	$Function_GetPlayerDataByte ( *Var7 6` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					EndIf							
				Default
					Call 	$Function_GetPlayerDataByte ( *Var5 2` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 2` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 3` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F292 )
					EndIf
					Call 	$Function_GetPlayerDataByte ( *Var5 5` )
					Mod 	*Var5 2`
					If *Var5 == 0`
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Div *Var6 2`
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					Else
						Call 	$Function_GetPlayerDataByte ( *Var6 5` )
						Mul *Var6 2`
						Call 	$Function_GetPlayerDataByte ( *Var7 6` )
						If *Var6 > *Var7
							Set *Var6 *Var7
						EndIf
						Call 	$Function_SetArbitraryByte  ( *Var6 8010F295 )
					EndIf
			EndSwitch
		Case == .Item:DarkCake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0`
			Set *Var1 0`
			Set *Var2 0`
			Call	 $Function_DebuffEffectUnified ( )
			Call	 $Function_SetDarkCake ( )			
		Case == .Item:SuperBunch				
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:SuperShroom *Var5 )
			EndIf
		Case == .Item:YoshiCake		%Yoshi Cake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call	 $Function_SetArbitraryByte ( 00000002 $ItemCostReductionData[2] )
			Call	 $Function_SetArbitraryByte ( 00000001 $ItemCostReductionData[3] )				
		Case == .Item:LeafShroom	%Leaf shroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0
			Set *Var1 0
			Set *Var2 30
			Call	 $Function_DebuffEffectUnified ( )
			%New effect (+4 atk and def for 2 turns, but -2 atk and def boost forever)			
			Call 	 $Function_SetChill 	( FFFFFFFC 00000002 )
			Call 	 $Function_SetDefdown 	( FFFFFFFC 00000002 )
			Call 	 $Function_AddAtkBoost  ( FFFFFFFE )
			Call 	 $Function_AddDefBoost  ( FFFFFFFE )
			%Old effect (-5 hp and fp for 3 turns)
			/%
				Old desc
				
				Dark food with weaker drawbacks.[BR]
				Restores 99 HP and 99 FP...[BR]
				Lose 15 HP and 15 FP over[BR]
				3 turns (-5 HP and FP per turn)[END]
			%/
			/%
			Set *DelayedHealAmount -5`
			Set *DelayedHealTurns   3  %the stuff that makes it actually work is in fivehealth.patch
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			If *VarF == 1`
				Set *DelayedHealTurns 4`
			EndIf
			If *VarF == 2`
				Set *DelayedHealTurns 6`
			EndIf				
			%/
		Case == .Item:MiracleJelly
			Call  $Function_TryAddMiracleJelly ( *VarD )
			If *VarD == 1`
				Call  GetActorPos   ( .Actor:Player *Var5 *Var6 *Var7 )
				Call  $Function_DebuffEffectPink ( )
			EndIf
			Label 	35
			Call 	RemoveItem ( .Item:MiracleJelly *Var6 )
			If *Var6 != FFFFFFFF
				Goto 35
			EndIf	
		Case == .Item:BakingSugar
			%Move costs are +5 but get hustle!
			%invis check
			%remove this... for now				
			Set *Var7 1`		%1 is valid
			/%
			Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
			Add   *Var5 00000218
			Call  $Function_GetArbitraryByte ( *Var6 *Var5 )		%player pointer + 218
			Set *Var7 0`
			If *Var6 != 0000000E
				Set *Var7 1`
			EndIf
			%/
			%
			If *Var7 != 1`
				Call $ShowCustomMessage	( 002F00FE 0000005A )
				Set *Var7 0`				
			EndIf
			If *Var7 == 1`
				Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
				Add *Var6 10`
				Call	 $Function_DebuffEffectWhite ( )
				Call	$Function_SetSugar ( )								
			EndIf
		Case == .Item:BakingSalt
			%3 atk for 3 turns
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 B1
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	 $Function_SetChill 	( FFFFFFFD 00000003 )			
		Case == .Item:BakingCream
			%healing is varB
			%fp healing is C
			Call	 $Function_GetPlayerDataByte ( *VarB 2` )					
			Call	 $Function_GetPlayerDataByte ( *VarC 5` )					
		Case == .Item:BakingStrawberry
			%-1 cost for 4 turns
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	 $Function_SetSaver 	( 00000001 00000003 )									
		Case == .Item:BakingButter
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call	 $Function_SetArbitraryByte ( 00000001 $ItemCostReductionData[2] )	
			Call	 $Function_SetArbitraryByte ( 00000001 $ItemCostReductionData[3] )			
		Case == .Item:BakingCleanser
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )
			Call	$Function_ResetStatus ( )
		Case == .Item:BakingMilk
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	 $Function_SetDefdown 	( FFFFFFFD 00000002 )
		Case == .Item:ShroomTrio
			%Add another one in your inventory
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:ShroomBunch *Var5 )
			EndIf
		Case == .Item:SuperTrio
			%Add another one in your inventory
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:SuperBunch *Var5 )
			EndIf
		Case == .Item:DualShroom
			%Add another one in your inventory
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:HalfShroom *Var5 )
			EndIf
		Case == .Item:BooLeaf
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call	$Function_SetBooLeaf2 ( )	%2		
				Case == 1`
					Call	$Function_SetBooLeaf ( )	%1
				Default
					Call	$Function_SetBooLeaf ( )	%1
			EndSwitch	
		Case == .Item:MiniSoda
			%Hustle + shrink for 3 turns
			%invis check
			Set *Var7 1`		%1 is valid
			Call  $Function_GetArbitraryWord ( *Var5 800DC148 )	%800DC070 + D8
			Add   *Var5 00000218
			Call  $Function_GetArbitraryByte ( *Var6 *Var5 )		%player pointer + 218
			Set *Var7 0`
			/%
			If *Var6 != 0000000E
				Set *Var7 1`
			EndIf
			%/
			Set *Var7 1`			
			%
			If *Var7 != 1`
				Call $ShowCustomMessage	( 002F00FE 0000005A )
				Set *Var7 0`				
			EndIf
			If *Var7 == 1`
				Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
				Add *Var6 10`
				Call	 $Function_DebuffEffectHotPink ( )
				Call	$Function_SetHustle ( )								
			EndIf		
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
		Case == .Item:DualJelly
			%Add another one in your inventory			
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:HalfJelly *Var5 )
			EndIf
		Case == .Item:MoltenShroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectOrange ( )
			Call 	$Function_GetPlayerDataByte ( *Var5 5` )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					If *Var5 > 100`
						Set *Var5 100`
					EndIf
				Case == 1`
					If *Var5 > 75`
						Set *Var5 75`
					EndIf
				Default
					If *Var5 > 50`
						Set *Var5 50`
					EndIf
			EndSwitch
			Mul *Var5 -1`
			%negative healing
			Call     $Function_FPHeal ( *Var5 )
			Mul *Var5 -1`
			%now positive
			Add *Var5 9`
			Div *Var5 10`						
			Mul *Var5 -1`
			%negative chill
			Call 	 $Function_SetChill 	( *Var5 00000003 )
		Case == .Item:MiracleGolden
			Call  $Function_TryAddMiracleJelly ( *VarD )
			If *VarD == 1`
				Call  GetActorPos   ( .Actor:Player *Var5 *Var6 *Var7 )
				Call  $Function_DebuffEffectPink ( )
			EndIf
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )
			Call	$Function_ResetStatus ( )			
			Label 	36
			Call 	RemoveItem ( .Item:MiracleGolden *Var6 )
			If *Var6 != FFFFFFFF
				Goto 36
			EndIf		
		Case == .Item:TradeoffShake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 0`
			Set *Var1 0`
			Set *Var2 0`
			Call	 $Function_DebuffEffectUnified ( )	
			Call  GetActorPos   ( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Add *Var5 5`
			Call  $Function_DebuffEffectPink ( )	
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call  $Function_TradeoffShake ( )
					Call  $Function_TradeoffShake ( )
				Case == 1`
					Call  $Function_TradeoffShake ( )
				Default
					Call  $Function_TradeoffShake ( )
			EndSwitch			
		Case == .Item:BombJuice
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 B1
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	 $Function_SetChill 	( FFFFFFFC 00000002 )
		Case == .Item:ShroomBunch
			Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
			If *VarF != 1`
				Call 	AddItem ( .Item:Mushroom *Var5 )
			EndIf
		Case == .Item:StarCake  %Star Cake
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call 	$Function_AddSP ( 00000800 )
				Case == 1`
					Call 	$Function_AddSP ( 00000600 )
				Default
					Call 	$Function_AddSP ( 00000400 )
			EndSwitch
			Call 	GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add 	*Var6 25`
			Call 	$Function_StarEffect ( *Var5 *Var6 *Var7 )
		CaseOR == .Item:DarkShroomCake
		CaseOR == .Item:GoldenShroomCake
		CaseOR == .Item:BakingFlour				%this is pretty garbage but lol
		CaseOR == .Item:ShroomCake
		CaseOR == .Item:SuperShroomCake
		CaseOR == .Item:UltraShroomCake
		CaseOR == .Item:DualShroomCake
		CaseOR == .Item:HalfShroomCake
			If *Var1 == .Item:DualShroomCake
				%Add another one in your inventory
				Call	$Function_GetArbitraryWord ( *VarF $WasLastItemAFreebie )
				If *VarF != 1`
					Call 	AddItem ( .Item:HalfShroomCake *Var5 )
				EndIf
			EndIf
			If *Var1 == .Item:DarkShroomCake
				Call     $Function_HPHeal ( FFFFFFF1 )
				Call     $Function_FPHeal ( FFFFFFF1 )				
			EndIf
			If *Var1 == .Item:GoldenShroomCake
				Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
				Add *Var6 10`
				Call	 $Function_DebuffEffectGold ( )
				Call	$Function_ResetStatus ( )
				Label 	30
				Call 	RemoveItem ( .Item:GoldenShroomCake *Var6 )
				If *Var6 != FFFFFFFF
					Goto 30
				EndIf					
			Else
				Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
				Add *Var6 10`
				Set *Var0 AE
				Set *Var1 FF
				Set *Var2 02
				Call	 $Function_DebuffEffectUnified ( )
			EndIf
			If *DelayedHealAmount == 0
				Set *DelayedHealAmount *Var[B]
				Add *DelayedHealTurns 3  %the stuff that makes it actually work is in fivehealth.patch
				Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
				If *VarF == 1`
					Add *DelayedHealTurns 1
				EndIf
				If *VarF == 2`
					Add *DelayedHealTurns 3
				EndIf
			Else %if you use another long-term heal while the first one is active
				%the strength of the effect will be of the stronger one
				If *Var[B] > *DelayedHealAmount
					%Step 1: calculate remaining total heal
					Set *Var[F] *DelayedHealAmount
					Mul *Var[F] *DelayedHealTurns						
					%*Var[F] = total heal amount
					%
					%Step 2:
					%set values to the stronger ones						
					Set *DelayedHealAmount *Var[B]
					Set *DelayedHealTurns 3  %add the normal healing too
					Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
					If *VarE == 1`
						Add *DelayedHealTurns 1
					EndIf
					If *VarE == 2`
						Add *DelayedHealTurns 3
					EndIf
					%
					%Step 3: apply bonus healing
					%Bonus turns = varF / amount
					Div *VarF *DelayedHealAmount
					Add *DelayedHealTurns *VarF
					If *VarF < 1`
						Add *DelayedHealTurns 1
					EndIf
				Else
					If *Var[B] == *DelayedHealAmount
						%equal => amount += (turncount)
						%Simple
						Add *DelayedHealTurns 3
						Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
						If *VarE == 1`
							Add *DelayedHealTurns 1
						EndIf
						If *VarE == 2`
							Add *DelayedHealTurns 3
						EndIf
					Else
						%Step 1: calculate new heal
						Set *Var[F] *Var[B]
						Mul *Var[F] 3
						Call	 $Function_GetArbitraryByte ( *VarE $ItemCostReductionData[2] )
						If *VarE == 1`
							Add *Var[F] *Var[B]
						EndIf
						If *VarE == 2`
							Add *Var[F] *Var[B]
							Add *Var[F] *Var[B]
							Add *Var[F] *Var[B]
						EndIf							
						%*Var[F] = total heal amount
						%
						%Step 2: apply bonus healing
						%Bonus turns = varF / amount
						Div *VarF *DelayedHealAmount
						Add *DelayedHealTurns *VarF
						If *VarF < 1`
							Add *DelayedHealTurns 1
						EndIf
					EndIf
				EndIf
			EndIf			
			If *DelayedHealTurns > 9`
				Set *DelayedHealTurns 9`
				Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
				Add *Var6 5`
				Set *Var0 00
				Set *Var1 80
				Set *Var2 00
				Call	 $Function_DebuffEffectUnified ( )				
			EndIf
			Goto 1
		EndCaseGroup
		Case == .Item:GoldenMelon
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )
			Call	$Function_ResetStatus ( )
		Case == .Item:BlueBerry %blue
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	 $Function_SetDefdown 	( FFFFFFFF 00000004 )
		Case == .Item:RedBerry %red
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 B1
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	 $Function_SetChill 	( FFFFFFFF 00000004 )
		Case == .Item:YellowBerry %yellow
			Call  GetActorPos   ( .Actor:Player *Var0 *Var1 *Var2 )
			Set   *Var3  00000014
			Call  MultiplyByActorScale  ( *Var3 )
			Add   *Var1  *Var3
			SetF  *Var3  *Fixed[1.0]
			Call  MultiplyByActorScale  ( *Var3 )
			Call  PlayEffect    ( ~FX:SnakingStatic *Var0 *Var1 *Var2 *Var3 0000001E 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
			Call  PlaySound     ( 00000379 )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call  $Function_ElectrifyMario2 ( )	%4
				Case == 1`
					Call  $Function_ElectrifyMario1 ( )	%3
				Default
					Call  $Function_ElectrifyMario ( )	%2
			EndSwitch
		Case == .Item:BubbleBerry %bubble
			Call  GetActorPos   ( .Actor:Player *Var0 *Var1 *Var2 )
			Add   *Var1  00000014
			Call  PlayEffect    ( ~FX:RadialFlowIn:WhiteWaves *Var0 *Var1 *Var2 *Fixed[1.0] 0000001E 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
			Call  PlaySoundAtActor  ( .Actor:Player 00000376 )
			Call  $AntiHustleDrink ( )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call	$Function_SetBubbleBerry2 ( )	%2		
				Case == 1`
					Call	$Function_SetBubbleBerry ( )	%1
				Default
					Call	$Function_SetBubbleBerry ( )	%1
			EndSwitch
		Case == .Item:Goomnut  %Goomnut
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call 	$Function_SetChill ( FFFFFFFF 00000003 )
		Case == .Item:KoopaLeaf	%Koopa leaf
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown ( FFFFFFFF 00000002 )
		Case == .Item:StrangeLeaf
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`		%double effect: does nothing :P
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )								
				Case == 1`		%*1.5 effect (hp -> ((max - hp) + hp)/2) (So actually hp -> maxhp/2 :P)
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )								
					Call	 $Function_GetPlayerDataByte ( *VarE 3` )		
					Div 	 *VarE 2`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F292 )
					Call	 $Function_GetPlayerDataByte ( *VarE 6` )
					Div 	 *VarE 2`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F295 )						
				Default			%"invert" hp and fp (hp -> max - hp)
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )						
					Call	 $Function_GetPlayerDataByte ( *VarF 2` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 3` )
					Sub 	 *VarE *VarF
					If *VarE < 1`
						Set *VarE 1`
					EndIf
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F292 )
					%
					Call	 $Function_GetPlayerDataByte ( *VarF 5` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 6` )
					Sub 	 *VarE *VarF
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F295 )
			EndSwitch
		Case == .Item:StinkyHerb
			%hp = (max - ((max hp - hp)/2))
			%hp = max - (max/2) + hp/2
			%hp = max / 2 + hp / 2
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`	%do the calculation twice (max + ((max/2 + hp/2)/2))
					%max/2 + (max/4 + hp/4)
					%max * 3/4 + hp/4
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )								
					Call	 $Function_GetPlayerDataByte ( *VarF 2` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 3` )
					Mul 	 *VarE 3`
					Add 	 *VarE *VarF
					Div 	 *VarE 4`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F292 )
					%
					Call	 $Function_GetPlayerDataByte ( *VarF 5` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 6` )
					Mul 	 *VarE 3`
					Add 	 *VarE *VarF
					Div 	 *VarE 4`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F295 )
				Case == 1`	%interpolate between above and below
					%(max * 3/4 + hp/4) + (max * 1/2 + hp * 1/2)  / 2
					%max * 5/8 + hp * 3/8
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )								
					Call	 $Function_GetPlayerDataByte ( *VarF 2` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 3` )
					Mul 	 *VarE 5`
					Add 	 *VarE *VarF
					Add 	 *VarE *VarF
					Add 	 *VarE *VarF
					Div 	 *VarE 8`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F292 )
					%
					Call	 $Function_GetPlayerDataByte ( *VarF 5` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 6` )
					Mul 	 *VarE 5`
					Add 	 *VarE *VarF
					Add 	 *VarE *VarF
					Add 	 *VarE *VarF
					Div 	 *VarE 8`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F295 )						
				Default
					Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
					Add *Var6 10`
					Set *Var0 B1
					Set *Var1 FF
					Set *Var2 B1
					Call	 $Function_DebuffEffectUnified ( )									
					Call	 $Function_GetPlayerDataByte ( *VarF 2` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 3` )
					Add 	 *VarE *VarF
					Div 	 *VarE 2`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F292 )
					%
					Call	 $Function_GetPlayerDataByte ( *VarF 5` )					
					Call	 $Function_GetPlayerDataByte ( *VarE 6` )
					Add 	 *VarE *VarF
					Div 	 *VarE 2`
					Call	 $Function_SetArbitraryByte  ( *VarE 8010F295 )
			EndSwitch
		Case == .Item:IcedPotato %Iced potato
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown ( FFFFFFFB 00000002 )
		Case == .Item:Koopasta
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown ( FFFFFFFC 00000001 )
		Case == .Item:ShroomSteak
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000001 00000003 )			
		Case == .Item:YummyMeal
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000001 00000003 )
		Case == .Item:BlandMeal
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000001 00000002 )
		Case == .Item:DeluxeFeast
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000001 00000004 )
		Case == .Item:SpecialShake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000003 00000002 )
		Case == .Item:BigCookie
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 FF
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )							
			Call 	$Function_SetSaver ( 00000005 00000002 )
		Case == .Item:KoopaTea %Koopa tea
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown ( FFFFFFFF 00000003 )
		Case == .Item:HoneyCandy %Honey candy
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			%debuff effect already appears because of paralyze
			%Call	 $Function_DebuffEffectLightBlue ( )
			Call 	$Function_SetChill 	 ( FFFFFFFF 00000003 )
			Call 	$Function_SetDefdown ( FFFFFFFF 00000003 )
		Case == .Item:LimeCandy %Lime candy			
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown ( FFFFFFFF 00000003 )
		Case == .Item:CocoPop %Cocopop
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call	 $Function_GetArbitraryByte ( *VarF $ItemCostReductionData[2] )
			Switch *VarF
				Case == 2`
					Call	$EnableAutoBlock2 ( )		%2
				Case == 1`
					Call	$EnableAutoBlock ( )
				Default
					Call	$EnableAutoBlock ( )
			EndSwitch
		Case == .Item:LemonCandy %Lemon candy
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 B1
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetChill 	 ( FFFFFFFF 00000003 )
		Case == .Item:FrozenFries %Frozen Fries
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetChill 	 ( 00000003 00000003 )
			Call 	$Function_SetDefdown ( FFFFFFFB 00000003 )
		Case == .Item:PotatoSalad
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetChill 	 ( 00000001 00000003 )
			Call 	$Function_SetDefdown ( FFFFFFFD 00000003 )	
		Case == .Item:NuttyCake %Nutty Cake
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call 	$Function_SetChill 	 ( FFFFFFFF 00000004 )
		Case == .Item:YoshiCookie
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectCoco ( )
			Call	 $Function_SetArbitraryByte ( 00000001 $ItemCostReductionData[2] )			
			Call	 $Function_SetArbitraryByte ( 00000001 $ItemCostReductionData[3] )				
		Case == .Item:GoldenShroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Call	 $Function_DebuffEffectGold ( )
			Call	$Function_ResetStatus ( )
		Case == .Item:PowerShroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 FF
			Set *Var1 B1
			Set *Var2 B1
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetChill 	 ( FFFFFFFE 00000003 )				
		Case == .Item:ShieldShroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 B1
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetDefdown 	 ( FFFFFFFE 00000003 )				
		Case == .Item:BoosterShroom
			Call     GetActorPos 	( .Actor:Player *Var5 *Var6 *Var7 )
			Add *Var6 10`
			Set *Var0 E3
			Set *Var1 B1
			Set *Var2 FF
			Call	 $Function_DebuffEffectUnified ( )			
			Call 	$Function_SetChill 	 ( FFFFFFFE 00000002 )				
			Call 	$Function_SetDefdown 	 ( FFFFFFFE 00000002 )				
	EndSwitch
	Set *VarF 0`
	Return
	Label 1			%theres a goto that would work in the original food script but not if I split it like this
	Set *VarF 1`
	Return
	End
}


%set var5, var6, var7 to correct position
#new:Function $Function_DebuffEffectPink
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, D0
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, D0
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, D0
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 90 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 90 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}


%0 if fail, 1 if success
#new:Function $Function_TryAddMiracleJelly
{
PUSH	S1, A1, A2, T0, RA
COPY	S1, A0
%get count
LAB		A0, $MiracleJellyData[1]
BNE		A0, R0, .nocount
NOP
ORI		A2, R0, 1
SAB		A2, $MiracleJellyData
.nocount
SLTI	A0, A0, 1		%1 -> 0, 0 -> 1
%set
COPY	A2, A0
COPY	A0, S1
JAL		~Func:set_variable
LW		A1, 0 (S0) %get argument
NOP
POP		S1, A1, A2, T0, RA
JR		RA
ADDIU	V0, R0, 2 	
}

#new:Function $Function_TransferToTurnCounts
{
	%A hacky way of making it easy to see if they have been modified is to temporarily store an impossible value in them
	%Store value = 0x10 * turncount (you can never get turncount of 16)
	PUSH	RA, A0, A1, A2	
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	LI		A2, $TurnCountList
	%
	LB		A1, 224 (A0) %str dur	
	SLL		A1, A1, 4				%Shift by 4 bits is *0x10
	SB		A1, 224 (A0) %str dur	
	SB		A1, 0 (A2)
	%
	LB		A1, 226 (A0) %def dur	
	SLL		A1, A1, 4				%Shift by 4 bits is *0x10
	SB		A1, 226 (A0) %str dur	
	SB		A1, 1 (A2)
	%
	LAB		A1, $ItemCostReductionData[1]		%turns
	SLL		A1, A1, 4				%Shift by 4 bits is *0x10
	SAB		A1, $ItemCostReductionData[1]		%turns
	SB		A1, 2 (A2)	
	POP		RA, A0, A1, A2
	JR		RA
	ORI 	V0, R0, 2
}

%Boost turn counts of atk, def and saver when they are not equal
#new:Function $Function_BoostTurnCounts
{
	%Undo the weird thing I did above and boost
	PUSH	RA, A0, A1, A2, A3, T0
	%Setup
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	LAB		A3, $ItemCostReductionData[2]
	%
	LB		A1, 224 (A0) %str dur	
	SLTI	T0, A1, 10
	BNE		T0, R0, .tryboost		%Below 16
	NOP
	SRL		A1, A1, 4				%Shift by 4 bits is /0x10
	SB		A1, 224 (A0) %str dur	
	BEQ		R0, R0, .dodefense
	NOP
	.tryboost
	BEQ		A3, R0, .dodefense
	NOP
	COPY	A2,	A1		%turncount
	COPY	T0, R0		
	SUB		T0, T0, A3
	ADDI	T0, T0, 2	%2 - (1 or 2)
	SRLV	A2, A2, T0
	ADD		A1, A2, A1
	SB		A1, 224 (A0) %str dur		
	%
	.dodefense
	LB		A1, 226 (A0) %str dur	
	SLTI	T0, A1, 10
	BNE		T0, R0, .tryboost2		%Below 16
	NOP
	SRL		A1, A1, 4				%Shift by 4 bits is /0x10
	SB		A1, 226 (A0) %str dur	
	BEQ		R0, R0, .dosaver
	NOP
	.tryboost2
	BEQ		A3, R0, .dosaver
	NOP
	COPY	A2,	A1		%turncount
	COPY	T0, R0		
	SUB		T0, T0, A3
	ADDI	T0, T0, 2	%2 - (1 or 2)
	SRLV	A2, A2, T0
	ADD		A1, A2, A1
	SB		A1, 226 (A0) %str dur		
	.dosaver
	%
	/%
	LI		A0, $ItemCostReductionData[1]
	LAB		A1, 0 (A0)		%turns
	SLL		A1, A1, 4				%Shift by 4 bits is *0x10
	SAB		A1, 0 (A0)		%turns
	SB		A1, 2 (A2)	
	%/
	LI		A0, $ItemCostReductionData[1]
	LB		A1, 0 (A0) %str dur	
	SLTI	T0, A1, 10
	BNE		T0, R0, .tryboost3		%Below 16
	NOP
	SRL		A1, A1, 4				%Shift by 4 bits is /0x10
	SB		A1, 0 (A0) %str dur	
	BEQ		R0, R0, .end
	NOP
	.tryboost3
	BEQ		A3, R0, .end
	NOP
	COPY	A2,	A1		%turncount
	COPY	T0, R0		
	SUB		T0, T0, A3
	ADDI	T0, T0, 2	%2 - (1 or 2)
	SRLV	A2, A2, T0
	ADD		A1, A2, A1
	SB		A1, 0 (A0) %str dur		
	.end
	%
	POP		RA, A0, A1, A2, A3, T0
	JR		RA
	ORI		V0, R0, 2
}



#new:Function $Function_StarEffect
{
    0:  ADDIU     SP, SP, FFD8
    4:  SW        S1, 1C (SP)
    8:  COPY      S1, A0
    C:  SW        RA, 24 (SP)
   10:  SW        S2, 20 (SP)
   14:  SW        S0, 18 (SP)
   18:  LW        S0, C (S1)
   1C:  LW        A1, 0 (S0)
   20:  JAL       ~Func:get_variable
   24:  ADDIU     S0, S0, 4
   28:  LW        A1, 0 (S0)
   2C:  ADDIU     S0, S0, 4
   30:  COPY      A0, S1
   34:  JAL       ~Func:get_variable
   38:  COPY      S2, V0
   3C:  COPY      A0, S1
   40:  LW        A1, 0 (S0)
   44:  JAL       ~Func:get_variable
   48:  COPY      S0, V0
   4C:  MTC1      S2, F2
   50:  NOP
   54:  CVT.S.W   F2, F2
   58:  MFC1      A1, F2
   5C:  MTC1      S0, F2
   60:  NOP
   64:  CVT.S.W   F2, F2
   68:  MFC1      A2, F2
   6C:  MTC1      V0, F2
   70:  NOP
   74:  CVT.S.W   F2, F2
   78:  LIF       F0, 40.0
   80:  MFC1      A3, F2
   84:  CLEAR     A0
   88:  JAL       8006FEF0
   8C:  SWC1      F0, 10 (SP)
   90:  LW        RA, 24 (SP)
   94:  LW        S2, 20 (SP)
   98:  LW        S1, 1C (SP)
   9C:  LW        S0, 18 (SP)
   A0:  LI        V0, 2
   A4:  JR        RA
   A8:  ADDIU     SP, SP, 28
}

#new:Function $Function_ResetStatus %set debuff turns to 0, set attack boost and defense boost to 0 (note that the partner buff moves work separately to them)
{
	PUSH	RA, A0, A1, S0
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	COPY 	S0, A0
	%SB		R0, 210 (A0) %debuff id
	%SB		R0, 211 (A0) %debuff turns
   14:  LB			V0, 210 (S0)
   18:  BEQ			V0, R0, .o30
   1C:  NOP
   20:  LH			A0, 436 (S0)
   24:  SB			R0, 211 (S0)
   28:  JAL			80047898
   2C:  SB			R0, 210 (S0)
   .o30									%this part clears the anim stuff and status 0D - was missing before
    30:  LB			V0, 216 (S0)
   34:  BEQ			V0, R0, .o0DClear
   38:  NOP
   3C:  LW			V0, 440 (S0)
   40:  SB			R0, 217 (S0)
   44:  SB			R0, 216 (S0)
   48:  LW			V0, C (V0)
   4C:  SW			R0, 3C (V0)
	.o0DClear
   30:  LB			V0, 212 (S0)
   34:  BEQ			V0, R0, .o4C
   38:  NOP
   3C:  LH			A0, 436 (S0)
   40:  SB			R0, 213 (S0)
   44:  JAL			800479A0
   48:  SB			R0, 212 (S0)
        .o4C
   4C:  LB			V0, 214 (S0)
   50:  BEQ			V0, R0, .o60
   54:  NOP
   58:  SB			R0, 215 (S0)
   5C:  SB			R0, 214 (S0)
        .o60
   60:  LB			V0, 218 (S0)
   64:  BEQ			V0, R0, .o74
   68:  NOP
   6C:  SB			R0, 219 (S0)
   70:  SB			R0, 218 (S0)
        .o74
	SB		R0, 221 (A0)
	SB		R0, 222 (A0)
	SAB		R0, $EternalCostIncreases
	POP		RA, A0, A1, S0
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $AntiHustleDrink
{
	PUSH 	RA, S0
	LIO 	A0, 800DC070
	SB		R0, 8B (A0) %hustle drink value
	%but also...
	LAB		S0, $EternalCostIncreases
	ADDI	S0, S0, 1
	SAB		S0, $EternalCostIncreases
	POP 	RA, S0
	JR 		RA
	ORI 	V0, R0, 2
}



#new:Function $Function_CureStatus %set debuff turns to 0, set attack boost and defense boost to 0 (note that the partner buff moves work separately to them)
{
	PUSH	RA, A0, A1, S0
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	COPY 	S0, A0
	%SB		R0, 210 (A0) %debuff id
	%SB		R0, 211 (A0) %debuff turns
   14:  LB			V0, 210 (S0)
   18:  BEQ			V0, R0, .o30
   1C:  NOP
   20:  LH			A0, 436 (S0)
   24:  SB			R0, 211 (S0)
   28:  JAL			80047898
   2C:  SB			R0, 210 (S0)
   .o30									%this part clears the anim stuff and status 0D - was missing before
    30:  LB			V0, 216 (S0)
   34:  BEQ			V0, R0, .o0DClear
   38:  NOP
   3C:  LW			V0, 440 (S0)
   40:  SB			R0, 217 (S0)
   44:  SB			R0, 216 (S0)
   48:  LW			V0, C (V0)
   4C:  SW			R0, 3C (V0)
	.o0DClear
   30:  LB			V0, 212 (S0)
   34:  BEQ			V0, R0, .o4C
   38:  NOP
   3C:  LH			A0, 436 (S0)
   40:  SB			R0, 213 (S0)
   44:  JAL			800479A0
   48:  SB			R0, 212 (S0)
        .o4C
   4C:  LB			V0, 214 (S0)
   50:  BEQ			V0, R0, .o60
   54:  NOP
   58:  SB			R0, 215 (S0)
   5C:  SB			R0, 214 (S0)
        .o60
   60:  LB			V0, 218 (S0)
   64:  BEQ			V0, R0, .o74
   68:  NOP
   6C:  SB			R0, 219 (S0)
   70:  SB			R0, 218 (S0)
        .o74
	POP		RA, A0, A1, S0
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_DualityShake
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	LB		A1, 223 (A0) %str
	SUB		A1, R0, A1
	SB		A1, 223 (A0) %str
	LB		A1, 225 (A0) %str
	SUB		A1, R0, A1
	SB		A1, 225 (A0) %str
	LI		A0, $ItemCostReductionData
	LB		A1, 0 (A0)
	SUB		A1, R0, A1
	SB		A1, 0 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_DualityShakeNull
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	SB		R0, 223 (A0) %str
	SB		R0, 225 (A0) %str
	LI		A0, $ItemCostReductionData
	SB		R0, 0 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

/%
#new:Function $Function_SetThreeAtk
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFE
	SB		A1, 223 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetThreeDef
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFE
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetKoopaLeaf
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 2
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetKoopaTea
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetKoopasta
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFC
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 1
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetGoomnut
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetNuttyCake
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	ADDIU	A1, R0, 4
	SB		A1, 224 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetIcedPotato
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFB
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 2
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetLemonCandy
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetLimeCandy
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetHoneyCandy
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetFrozenFries
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, 0003
	SB		A1, 223 (A0) %chill str
	ADDI	A1, R0, FFFB
	SB		A1, 225 (A0) %defdown str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %chill dur
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetPotatoSalad
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, 0001
	SB		A1, 223 (A0) %chill str
	ADDI	A1, R0, FFFD
	SB		A1, 225 (A0) %defdown str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %chill dur
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}


#new:Function $Function_SetAtkDef
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFE
	SB		A1, 223 (A0) %chill str
	SB		A1, 225 (A0) %defdown str
	ADDIU	A1, R0, 2
	SB		A1, 224 (A0) %chill dur
	SB		A1, 226 (A0) %defdown dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetDarkLeaf
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetDarkShroom
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFD
	SB		A1, 223 (A0) %str
	ADDI	A1, R0, 0003
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 224 (A0) %dur
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}
%/

#new:Function $Function_SetDarkCake
{
	PUSH	RA, A0, A1, A2, A3
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFE
	SB		A1, 223 (A0) %str
	SB		A1, 225 (A0) %str
	%Get turns
	LI		A2, 8010F520
	LB		A3, 0 (A2)
	SH		R0, 0 (A2)	
	%ADDIU	A1, R0, 3
	COPY	A1, A3
	SB		A1, 224 (A0) %dur
	SB		A1, 226 (A0) %dur
	SLTI	A3, A1, 10
	BNE		A3, R0, .noset
	NOP
	ORI		A1, R0, F
	SB		A1, 224 (A0) %dur
	SB		A1, 226 (A0) %dur
	.noset
	POP		RA, A0, A1, A2, A3
	JR		RA
	ORI 	V0, R0, 2
}

/%
#new:Function $Function_SetRedBerry
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 223 (A0) %str
	ADDIU	A1, R0, 4
	SB		A1, 224 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetBlueBerry
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFF
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 4
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}
%/

#new:Function:Battle $Function_ElectrifyMario
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
    C:  LAW       S0, 800DC148
   14:  LI        A1, B
   18:  SW        RA, 14 (SP)
   %1C:  LW        A2, 84 (V0)
		ORI 	  A2, R0, 2
   20:  JAL       ~Func:inflict_status
   24:  COPY      A0, S0
   28:  SB        R0, 21C (S0)
   2C:  LW        RA, 14 (SP)
   30:  LW        S0, 10 (SP)
   34:  LI        V0, 2
   38:  JR        RA
   3C:  ADDIU     SP, SP, 18
}

#new:Function:Battle $Function_ElectrifyMario1
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
    C:  LAW       S0, 800DC148
   14:  LI        A1, B
   18:  SW        RA, 14 (SP)
   %1C:  LW        A2, 84 (V0)
		ORI 	  A2, R0, 3
   20:  JAL       ~Func:inflict_status
   24:  COPY      A0, S0
   28:  SB        R0, 21C (S0)
   2C:  LW        RA, 14 (SP)
   30:  LW        S0, 10 (SP)
   34:  LI        V0, 2
   38:  JR        RA
   3C:  ADDIU     SP, SP, 18
}

#new:Function:Battle $Function_ElectrifyMario2
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
    C:  LAW       S0, 800DC148
   14:  LI        A1, B
   18:  SW        RA, 14 (SP)
   %1C:  LW        A2, 84 (V0)
		ORI 	  A2, R0, 4
   20:  JAL       ~Func:inflict_status
   24:  COPY      A0, S0
   28:  SB        R0, 21C (S0)
   2C:  LW        RA, 14 (SP)
   30:  LW        S0, 10 (SP)
   34:  LI        V0, 2
   38:  JR        RA
   3C:  ADDIU     SP, SP, 18
}

#new:Function:Battle $Function_SetBooLeaf
{
    0:  ADDIU     SP, SP, FFE0
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
		LAB		  S0, $EternalCostIncreases
		ADDI	  S0, S0, 1
		SAB		  S0, $EternalCostIncreases	
    C:  LAW       S0, 800DC148
   14:  LI        A1, E
   18:  SW        RA, 18 (SP)
   1C:  SW        S1, 14 (SP)   
   %20:  LW        A2, 84 (V0)
		ORI		  A2, R0, 1
   24:  LW        S1, 1F4 (S0)
   28:  JAL       ~Func:inflict_status
   2C:  COPY      A0, S0
   30:  SB        R0, 21C (S0)
   34:  LW        V1, 0 (S1)
   38:  ORI       V1, V1, 100
   3C:  SW        V1, 0 (S1)
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  LI        V0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

#new:Function:Battle $Function_SetBooLeaf2
{
    0:  ADDIU     SP, SP, FFE0
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
		LAB		  S0, $EternalCostIncreases
		ADDI	  S0, S0, 2
		SAB		  S0, $EternalCostIncreases		
    C:  LAW       S0, 800DC148
   14:  LI        A1, E
   18:  SW        RA, 18 (SP)
   1C:  SW        S1, 14 (SP)
   %20:  LW        A2, 84 (V0)
		ORI		  A2, R0, 2
   24:  LW        S1, 1F4 (S0)
   28:  JAL       ~Func:inflict_status
   2C:  COPY      A0, S0
   30:  SB        R0, 21C (S0)
   34:  LW        V1, 0 (S1)
   38:  ORI       V1, V1, 100
   3C:  SW        V1, 0 (S1)
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  LI        V0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

#new:Function:Battle $Function_SetBubbleBerry
{
    0:  ADDIU     SP, SP, FFE0
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
		LAB		  S0, $EternalCostIncreases
		ADDI	  S0, S0, 1
		SAB		  S0, $EternalCostIncreases		
    C:  LAW       S0, 800DC148
		%
		ADDI	A1, R0, 0002
		SB		A1, 223 (S0) %str
		SB		A1, 225 (S0) %str
		ADDIU	A1, R0, 3
		SB		A1, 224 (S0) %dur
		SB		A1, 226 (S0) %dur
		%
   14:  LI        A1, E
   18:  SW        RA, 18 (SP)
   1C:  SW        S1, 14 (SP)
   %20:  LW        A2, 84 (V0)
		ORI		  A2, R0, 1
   24:  LW        S1, 1F4 (S0)
   28:  JAL       ~Func:inflict_status
   2C:  COPY      A0, S0
   30:  SB        R0, 21C (S0)
   34:  LW        V1, 0 (S1)
   38:  ORI       V1, V1, 100
   3C:  SW        V1, 0 (S1)
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  LI        V0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

#new:Function:Battle $Function_ApplyVanish
{
    0:  ADDIU     SP, SP, FFE0
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
    C:  LAW       S0, 800DC148
   14:  LI        A1, E
   18:  SW        RA, 18 (SP)
   1C:  SW        S1, 14 (SP)
   %20:  LW        A2, 84 (V0)
		ORI		  A2, R0, 1
   24:  LW        S1, 1F4 (S0)
   28:  JAL       ~Func:inflict_status
   2C:  COPY      A0, S0
   30:  SB        R0, 21C (S0)
   34:  LW        V1, 0 (S1)
   38:  ORI       V1, V1, 100
   3C:  SW        V1, 0 (S1)
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  LI        V0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

#new:Function:Battle $Function_SetBubbleBerry2
{
    0:  ADDIU     SP, SP, FFE0
    4:  COPY      V0, A0
    8:  SW        S0, 10 (SP)
		LAB		  S0, $EternalCostIncreases
		ADDI	  S0, S0, 2
		SAB		  S0, $EternalCostIncreases	
    C:  LAW       S0, 800DC148
		%
		ADDI	A1, R0, 0002
		SB		A1, 223 (S0) %str
		SB		A1, 225 (S0) %str
		ADDIU	A1, R0, 3
		SB		A1, 224 (S0) %dur
		SB		A1, 226 (S0) %dur
		%
   14:  LI        A1, E
   18:  SW        RA, 18 (SP)
   1C:  SW        S1, 14 (SP)
   %20:  LW        A2, 84 (V0)
		ORI		  A2, R0, 2
   24:  LW        S1, 1F4 (S0)
   28:  JAL       ~Func:inflict_status
   2C:  COPY      A0, S0
   30:  SB        R0, 21C (S0)
   34:  LW        V1, 0 (S1)
   38:  ORI       V1, V1, 100
   3C:  SW        V1, 0 (S1)
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  LI        V0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

#new:Function $EnableAutoBlock2
{
	LAB 	V0, $BattlePerks[2]
	ADDIU 	V0, V0, 2
	SAB 	V0, $BattlePerks[2]
	JR RA
	ADDIU	V0, R0, 2
}

/%
#new:Function $Function_SetBlandMeal
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 2
	SB		A1, 0 (A0)
	LI 		A1, 2
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetYummyMeal
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 2
	SB		A1, 0 (A0)
	LI 		A1, 3
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetDeluxeFeast
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 2
	SB		A1, 0 (A0)
	LI 		A1, 4
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetSpecialShake
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 3
	SB		A1, 0 (A0)
	LI 		A1, 3
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetBigCookie
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 5
	SB		A1, 0 (A0)
	LI 		A1, 2
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}


#new:Function $Function_SetShroomSteak
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, 2
	SB		A1, 0 (A0)
	LI 		A1, 3
	SB		A1, 1 (A0)
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}

#new:Function $Function_SetSalt
{
	PUSH	RA, A0, A1
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	ADDI	A1, R0, FFFD
	SB		A1, 225 (A0) %str
	ADDIU	A1, R0, 3
	SB		A1, 226 (A0) %dur
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}
%/

#new:Function $Function_SetSugar
{
	PUSH	RA, A0, A1
	LI		A0, $ItemCostReductionData
	LI 		A1, FFFB		%-5
	SB		A1, 0 (A0)
	LI 		A1, 3
	SB		A1, 1 (A0)	
	%Now apply hustle?
	LAB		  V0, $AntiHustleToken
	BEQ		  V0, R0, .noHustleA
	ADDIU     V0, R0, 2
	%hustle is set - store to battle perks
	.yeshustle
	ADDIU     V0, R0, 2
	SAB		  V0, $BattlePerks[1]
	POP		RA, A0, A1
	JR		  RA
	ADDIU     V0, R0, 2		
	%hustle is not set? - store in the regular place
	.noHustleA
	LAB     V0, 800DC0FB	%hustle tracker
	BNE		V0, R0, .yeshustle
	NOP
	LI		V0, 2
	SAB     V0, 800DC0FB	%hustle tracker
	LI		V0, 1
	SAB		V0, $AntiHustleToken
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}



#new:Function $Function_SetHustle
{
	PUSH	RA, A0, A1
	%Now apply hustle?
	LAB		  V0, $AntiHustleToken
	BEQ		  V0, R0, .noHustleA
	ADDIU     V0, R0, 2
	%hustle is set - store to battle perks
	.yeshustle
	ADDIU     V0, R0, 2
	SAB		  V0, $BattlePerks[1]
	POP		RA, A0, A1
	JR		  RA
	ADDIU     V0, R0, 2		
	%hustle is not set? - store in the regular place
	.noHustleA
	LAB     V0, 800DC0FB	%hustle tracker
	BNE		V0, R0, .yeshustle
	NOP
	LI		V0, 2
	SAB     V0, 800DC0FB	%hustle tracker
	LI		V0, 1
	SAB		V0, $AntiHustleToken
	POP		RA, A0, A1
	JR		RA
	ORI 	V0, R0, 2
}



#new:Function $Function_SetChill %( strength, turncount )
{
PUSH RA, A0, A1, S0, S1, S2
COPY	S2, A0
LW		S1, C (A0)
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 1
COPY	S0, V0
ADDIU	S1, S1, 4
COPY	A0, S2
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 2
%S0 = 1
%V0 = 2
LIO		A0, 800DC070
LW		A0, D8 (A0) %where player actor struct is
COPY	A1, S0
SB		A1, 223 (A0) %str
COPY	A1, V0
SB		A1, 224 (A0) %dur
POP RA, A0, A1, S0, S1, S2
JR	RA
ADDIU	V0, R0, 2
}

#new:Function $Function_SetDefdown %( strength, turncount )
{
PUSH RA, A0, A1, S0, S1, S2
COPY	S2, A0
LW		S1, C (A0)
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 1
COPY	S0, V0
ADDIU	S1, S1, 4
COPY	A0, S2
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 2
%S0 = 1
%V0 = 2
LIO		A0, 800DC070
LW		A0, D8 (A0) %where player actor struct is
COPY	A1, S0
SB		A1, 225 (A0) %str
COPY	A1, V0
SB		A1, 226 (A0) %dur
POP RA, A0, A1, S0, S1, S2
JR	RA
ADDIU	V0, R0, 2
}

#new:Function $Function_SetSaver %( strength, turncount )
{
PUSH RA, A0, A1, S0, S1, S2
COPY	S2, A0
LW		S1, C (A0)
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 1
COPY	S0, V0
ADDIU	S1, S1, 4
COPY	A0, S2
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 2
%S0 = 1
%V0 = 2
LI		A0, $ItemCostReductionData
COPY	A1, S0
SB		A1, 0 (A0)		%amount
COPY	A1, V0
SB		A1, 1 (A0)		%count
POP RA, A0, A1, S0, S1, S2
JR	RA
ADDIU	V0, R0, 2
}


#new:Function $Function_AddAtkBoost %( strength )
{
PUSH RA, A0, A1, S0, S1, S2
COPY	S2, A0
LW		S1, C (A0)
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 1
COPY	S0, V0
%S0 = 1
LIO		A0, 800DC070
LW		A0, D8 (A0) %where player actor struct is
LB		A1, 221 (A0) %str
ADD		A1, A1, S0
SB		A1, 221 (A0) %str
POP RA, A0, A1, S0, S1, S2
JR	RA
ADDIU	V0, R0, 2
}

#new:Function $Function_AddDefBoost %( strength )
{
PUSH RA, A0, A1, S0, S1, S2
COPY	S2, A0
LW		S1, C (A0)
JAL		~Func:get_variable
LW		A1, 0 (S1) %get argument 1
COPY	S0, V0
%S0 = 1
LIO		A0, 800DC070
LW		A0, D8 (A0) %where player actor struct is
COPY	A1, S0
LB		A1, 222 (A0) %str
ADD		A1, A1, S0
SB		A1, 222 (A0) %str
POP RA, A0, A1, S0, S1, S2
JR	RA
ADDIU	V0, R0, 2
}

#new:Function $Function_TradeoffShake
{
	PUSH RA, A0, A1, S0, S1, S2
	LIO		A0, 800DC070
	LW		A0, D8 (A0) %where player actor struct is
	LBU		A1, 224 (A0) %turncount
	ADDI	A1, A1, FFFF
	SLTI	V0, A1, 1
	BNE		V0, R0, .noatk
	NOP
	SB		A1, 224 (A0) %turncount
	LBU		A1, 223 (A0) %str
	ADDI	A1, A1, FFFF
	SB		A1, 223 (A0) %str
	.noatk
	LBU		A1, 226 (A0) %turncount
	ADDI	A1, A1, FFFF
	SLTI	V0, A1, 1
	BNE		V0, R0, .nodef
	NOP
	SB		A1, 226 (A0) %turncount
	LB		A1, 225 (A0) %str
	ADDI	A1, A1, FFFF
	SB		A1, 225 (A0) %str
	.nodef
	LI		A0, $ItemCostReductionData
	LBU		A1, 1 (A0) %turncount
	ADDI	A1, A1, FFFF
	SLTI	V0, A1, 1
	BNE		V0, R0, .nosaver
	NOP
	SB		A1, 1 (A0) %turncount
	LB		A1, 0 (A0) %str
	ADDI	A1, A1, 1
	SB		A1, 0 (A0) %str
	.nosaver
	POP RA, A0, A1, S0, S1, S2
	JR	RA
	ADDIU	V0, R0, 2	
}


%set var5, var6, var7 to correct position
%DC, CC, BC
#new:Function $Function_DebuffEffectCoco
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, DC 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, CC
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, BC
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%orange
%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectOrange
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, 90
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 33
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}


%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectGold
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, DD
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 2E
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, FF, FF
#new:Function $Function_DebuffEffectHotPink
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, 67
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, D0
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 67 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, D0 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, FF, FF
#new:Function $Function_DebuffEffectWhite
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, FF
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}
/%
%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectLightYellow
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, B1
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 70 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectLightBlue
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, B1 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, B1
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, FF
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectLightRed
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, B1
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, B1
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectLightPurple
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, E3 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, B1
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, FF
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%FF, DD, 2E
#new:Function $Function_DebuffEffectLightGreen
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, B1 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, B1
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

%set var5, var6, var7 to correct position
%AE, FF, 02
#new:Function $Function_DebuffEffectLime
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, AE 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, FF
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 02
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 70
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, FF 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, FF 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}


%set var5, var6, var7 to correct position
#new:Function $Function_DebuffEffectBlue
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 50
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 90 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

#new:Function $Function_DebuffEffectDarkBlue
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 30
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 60 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}

#new:Function $Function_DebuffEffectBlack
{
    0:  ADDIU     SP, SP, FFE8
    4:  COPY      V0, A0
    8:  SW        RA, 10 (SP)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		ADDIU     A0, R0, 00
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 40 
   74:  SB        V0, 3D (V1)						%color byte 6?
   78:  LW        RA, 10 (SP)
   7C:  ADDIU     V0, R0, 2   						%return 2
   80:  JR        RA
   84:  ADDIU     SP, SP, 18
}
%/

%use var0, var1, var2 for color
%var5, var6, var7 for positions
#new:Function $Function_DebuffEffectUnified
{
		PUSH	  RA, S0, S1, S2
    4:  COPY      V0, A0
		LW		  S0, 84 (V0)
		LW		  S1, 88 (V0)
		LW		  S2, 8C (V0)
    C:  LWC1      F0, 98 (V0)				%84 (var0) -> 98 (var5)
   10:  CVT.S.W   F0, F0
   14:  MFC1      A1, F0
   18:  LWC1      F0, 9C (V0)
   1C:  CVT.S.W   F0, F0
   20:  MFC1      A2, F0
   24:  LWC1      F0, A0 (V0)
   28:  CVT.S.W   F0, F0
   2C:  MFC1      A3, F0
   30:  JAL       80070AF0
   34:  ADDIU     A0, R0, 2   
   38:  LW        A0, C (V0)
		COPY	  V1, S0
		%ADDIU     V1, R0, 00 
   40:  SB        V1, 38 (A0)						%color byte 1?
   44:  LW        A0, C (V0)
		COPY	  V1, S1
		%ADDIU     V1, R0, 00
   4C:  SB        V1, 39 (A0)						%color byte 2?
   50:  LW        V1, C (V0)
		COPY	  A0, S2
		%ADDIU     A0, R0, 00
   54:  SB        A0, 3A (V1)						%color byte 3?
   58:  LW        A0, C (V0)
		ADDIU     V1, R0, 00
		COPY	  V1, S0
   60:  SB        V1, 3B (A0)						%color byte 4? (unused?)
   64:  LW        A0, C (V0)
		ADDIU     V1, R0, 00 
		COPY	  V1, S1
   6C:  SB        V1, 3C (A0)						%color byte 5?
   70:  LW        V1, C (V0)
		ADDIU     V0, R0, 40 
		COPY	  A0, S2
   74:  SB        V0, 3D (V1)						%color byte 6?
   7C:  ADDIU     V0, R0, 2   						%return 2
		POP		  RA, S0, S1, S2
   80:  JR        RA
		NOP
}