%Copied from regular atomic boo

%Dark Collective
%	80 hp, 0 def, 0 atk!
%	However, each hit he takes causes him to release a Dark Fragment
%	Dark Fragments are invisible, and on each of their turns, they will rush towards you to deal 5 damage and then go back into Dark Collective and heal him for 4

%Each turn, the dark collective gets +1 atk (all the fragments get +1 too)

%	Strats are similar to huff n puff, but you have to use strong single hits (not fan smack)


#define .AnimStop	00EF0505
#define .AnimIdle	00EF0500
#define .AnimRun	00EF0505
#define .AnimPain	00EF0501
#define .AnimHide	00EF0502
#define .AnimSpook	00EF0503

%might add dizzy animation later
%#define .AnimDizzy	00F00509
%#define .AnimDead	00F00512 %unused?
#define .AnimDead	00EF0501


#new:Actor $DarkCollective
{
% stats
[Index]        C2b 
[Level]        70`b %miniboss stats 
[MaxHP]       120`b 
[Coins]         0`b 
[Flags]       00000200 
[StatusTable] $StatusTable_DarkCollective 
% ai
[PartsCount]   1`s 
[PartsTable] $PartsTable_DarkCollective 
[Script]      $Script_Init_DarkCollective 
% move effectiveness
[Escape]        0`b %no escape 
[Item]          0`b 
[AirLift]       0`b 
[Hurricane]     0`b % Bow's "Spook" as well
[UpAndAway]     0`b 
[PowerBounce]   3`b 
[SpinSmash]     4`b % weight (0-4)
% ui positions
[Size]        100`b 100`b % width height
[HealthBar]     0`b   0`b % dx dy
[StatusTurn]  -45`b 75`b % dx dy (usually top left)
[StatusIcon]   45`b 75`b % dx dy (usually top right)
}

%regular boo is 48 x 40, atomic boo is (usually) 120 x 108

#new:StatusTable $StatusTable_DarkCollective 
{
.Status:Normal            0`
.Status:Sleep             0` 
.Status:Poison            0`
.Status:Frozen            0`
.Status:Dizzy             0` %I don't have animations for dizzy yet
.Status:Static            0`
.Status:Paralyze          0`
.Status:Shrink            0`
.Status:Stop              0`
.Status:SleepTurnMod      0`
.Status:PoisonTurnMod     0`
.Status:FrozenTurnMod     0`
.Status:DizzyTurnMod     -1`
.Status:StaticTurnMod     0`
.Status:ParalyzeTurnMod  -1`
.Status:ShrinkTurnMod     1`
.Status:StopTurnMod      -1`
.Status:End
}

#new:PartsTable $PartsTable_DarkCollective
{
00800000 01000000 003C00FF $IdleAnimations_DarkCollective $DefenseTable_DarkCollective 00000000 00000000 FDF60000 00000000 
}

#new:IdleAnimations $IdleAnimations_DarkCollective
{
.Status:Normal    .AnimIdle
.Status:Stone     .AnimStop
.Status:Sleep     .AnimStop %.AnimSleep
.Status:Poison    .AnimIdle
.Status:Stop      .AnimStop
.Status:Static    .AnimIdle
.Status:Paralyze  .AnimStop
.Status:Dizzy     .AnimPain %.AnimDizzy
.Status:End
}

#new:DefenseTable $DefenseTable_DarkCollective
{
.Element:Normal 00000000
.Element:Throw FFFFFFFF
.Element:End
}

%don't give atomic boo a free turn
/%
% Immediately vanishes owner of calling script.
#new:Function $Function_Vanish_DarkCollective % ( duration )
	ADDIU	SP, SP, FFE0
	SW		RA, 10 (SP)
	SW		S1, 14 (SP)
	SW		S2, 18 (SP)
	% get turn count
	LW		A1, 0 (S0)
	JAL		~Func:get_variable
	DADDU	S1, A0, R0
	ANDI	V0, V0, 00FF
	% add electify status
	LW		A0, 148 (S1)
	JAL		~Func:get_actor
	DADDU	S2, V0, R0
	ORI		S2, S2, 0E00
	SH		S2, 218 (V0)
	% return
	LW		RA, 10 (SP)
	LW		S1, 14 (SP)
	LW		S2, 18 (SP)
	ADDIU	V0, R0, 2
	JR		RA
	ADDIU	SP, SP, 20
%/

#new:Script $Script_Init_DarkCollective
{
	Call	BindTakeTurn	( .Actor:Self $Script_TakeTurn_DarkCollective )
	Call	BindIdle		( .Actor:Self $Script_Idle_DarkCollective )
	Call	BindHandleEvent	( .Actor:Self $Script_HandleEvent_DarkCollective )
	Call	GetActorPos		( .Actor:Self *Var[0] *Var[1] *Var[2] )
	Call	SetActorVar		( .Actor:Self 00000000 .False )
	Call	SetActorVar		( .Actor:Self 00000001 00000000 )
	Call	SetActorVar 	(.Actor:Self 00000002 00000000 ) %open slots
	Call	SetActorVar 	(.Actor:Self 00000003 00000000 ) %ai state
	Add  *Var[1]  10` 
	Call	ForceHomePos	( .Actor:Self *Var[0] *Var[1] *Var[2] )
	Call	HPBarToHome		( .Actor:Self )
	   % 75% chance to spawn with invisible status
	%Call	RandInt	 ( 100` *Var[0] )
	%If	*Var[0] > 75`
	%	Call	$Function_Vanish_DarkCollective ( 1 )
	%EndIf
	Call	 $SetAuraToDark ( )
	Call     AddActorDecoration 	( .Actor:Self 00000001 00000000 00000001 )	%dark fire now (was gold but I used special functions)
	Call     ModifyActorDecoration 	( .Actor:Self 00000001 00000000 125` 125` 00000000 00000000 )	
	Return
	End
}

#new:Script $Script_Idle_DarkCollective
{
	Call	RandInt	( 10` *Var[0] ) % randomize initial pattern a little
	Wait	*Var[0]
	Label	00000000 
	Call	MakeLerp    	( 00000000 0000000A 00000019 0000000A )
	Label	00000001 
	Call	UpdateLerp  	( )
	Call	GetHomePos  	( .Actor:Self *Var[2] *Var[3] *Var[4] )
	Add  *Var[0]  *Var[3] 
	Call	SetActorPos 	( .Actor:Self *Var[2] *Var[0] *Var[4] )
	If  *Var[1]  ==  00000001 
		Label	0000000B 
		Wait	00000001 
		Call	GetStatusFlags ( .Actor:Self *Var[0] )
		If  *Var[0]  &  0035D000 
			Goto	0000000B 
		EndIf
		Goto	00000001 
	EndIf
	Call	MakeLerp    	( 0000000A 00000000 00000019 0000000A )
	Label	00000002 
	Call	UpdateLerp  	( )
	Call	GetHomePos  	( .Actor:Self *Var[2] *Var[3] *Var[4] )
	Add  *Var[0]  *Var[3] 
	Call	SetActorPos 	( .Actor:Self *Var[2] *Var[0] *Var[4] )
	If  *Var[1]  ==  00000001 
		Label	00000016 
		Wait	00000001 
		Call	GetStatusFlags ( .Actor:Self *Var[0] )
		If  *Var[0]  &  0035D000 
			Goto	00000016 
		EndIf
		Goto	00000002 
	EndIf
	Goto	00000000 
	Return
	End
}

#new:Script $Script_ReturnHome_DarkCollective
{
	Call     SetAnimation 	( .Actor:Self 00000001 .AnimRun )
	Call     SetGoalToHome 	( .Actor:Self )
	Call     SetActorSpeed 	( .Actor:Self *Fixed[8.0] )
	Thread
		Call     $Function_ReturnHome_DarkCollective ( )
	EndThread
	Call     FlyToGoal  	( .Actor:Self 00000000 00000001 .Easing:SinOut )
	Call     SetAnimation 	( .Actor:Self 00000001 .AnimIdle )
	Return
	End
}
	
#new:Function $Function_ReturnHome_DarkCollective
{
	ADDIU     SP, SP, FFD8
	SW        S2, 20 (SP)
	DADDU     S2, A0, R0
	SW        RA, 24 (SP)
	SW        S1, 1C (SP)
	SW        S0, 18 (SP)
	LW        A0, 148 (S2)
	JAL       ~Func:get_actor
	DADDU     S0, A1, R0
	BEQ       S0, R0, .oDC
	DADDU     S1, V0, R0
	LWC1      F2, 18 (S1)
	LWC1      F0, 144 (S1)
	SUB.S     F2, F2, F0
	MUL.S     F2, F2, F2
	NOP
	LWC1      F6, 1C (S1)
	LWC1      F0, 148 (S1)
	SUB.S     F6, F6, F0
	MUL.S     F6, F6, F6
	NOP
	LWC1      F4, 14C (S1)
	LWC1      F0, 20 (S1)
	SUB.S     F0, F0, F4
	MUL.S     F0, F0, F0
	NOP
	ADD.S     F2, F2, F6
	ADD.S     F12, F2, F0
	SQRT.S    F4, F12
	C.EQ.S    F4, F4
	NOP
	BC1T      .o90
	NOP
	JAL       80061EF0
	NOP
	MOV.S     F4, F0
        .o90
	LWC1      F0, 4C (S1)
	LIF       F2, 0.5
	DIV.S     F0, F4, F0
	MUL.S     F0, F0, F2
	NOP
	LIF       F2, 1.0
	NOP
	ADD.S     F0, F0, F2
	TRUNC.W.S F8, F0
	SWC1      F8, 70 (S2)
	LWC1      F0, 14C (S1)
	ADDIU     A0, R0, 359
	SWC1      F0, 10 (SP)
	LW        A2, 144 (S1)
	LW        A3, 148 (S1)
	JAL       80149D5C
	DADDU     A1, R0, R0
        .oDC
	LW        V0, 70 (S2)
	DADDU     V1, V0, R0
	ADDIU     V0, V0, FFFF
	BGTZ      V1, .o114
	SW        V0, 70 (S2)
	LWC1      F0, 14C (S1)
	ADDIU     A0, R0, 759
	SWC1      F0, 10 (SP)
	LW        A2, 144 (S1)
	LW        A3, 148 (S1)
	JAL       80149D5C
	DADDU     A1, R0, R0
	BEQ       R0, R0, .o118
	ADDIU     V0, R0, 2
        .o114
	DADDU     V0, R0, R0
        .o118
	LW        RA, 24 (SP)
	LW        S2, 20 (SP)
	LW        S1, 1C (SP)
	LW        S0, 18 (SP)
	JR        RA
	ADDIU     SP, SP, 28
}

#new:Script $Script_HandleEvent_DarkCollective
{
	Call     UseIdleAnimation 	( .Actor:Self .False )
	Call     EnableIdleScript 	( .Actor:Self 00000000 )
	Call     GetLastEvent 	( .Actor:Self *Var[0] )
	Switch  *Var[0] 
		CaseOR  ==  .Event:HitCombo
		CaseOR  ==  .Event:Hit
			ExecWait $Script_ShedDarkFragments
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoNormalHit 
		EndCaseGroup
		Case  ==  .Event:BurnHit
			ExecWait $Script_ShedDarkFragments
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			SetConst  *Var[2]  .AnimDead 
			ExecWait DoBurnHit 
		Case  ==  .Event:BurnDeath
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			SetConst  *Var[2]  .AnimDead 
			ExecWait DoBurnHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimDead 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:SpinSmashHit
			ExecWait $Script_ShedDarkFragments
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait 8029B998 
		Case  ==  .Event:SpinSmashDeath
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait 8029B998 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:ShockHit
			Call     PlaySoundAtActor 	( .Actor:Self 00000759 )
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoShockHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait 8029BD70 
			ExecWait $Script_ReturnHome_DarkCollective 
		Case  ==  .Event:ShockDeath
			Call     PlaySoundAtActor 	( .Actor:Self 00000759 )
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoShockHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoDeath 
			Return
		CaseOR  ==  00000017
		CaseOR  ==  .Event:Immune
		CaseOR  ==  .Event:AirLiftFailed
		CaseOR  ==  .Event:BurnTaunt
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimIdle 
			ExecWait DoImmune 
		EndCaseGroup
		Case  ==  .Event:Death
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoNormalHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPain 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:BeginFirstStrike
			Call     SetActorPos 	( .Actor:Self 00000014 00000000 00000000 )
			Call     HPBarToCurrent ( .Actor:Self )
		Case  ==  .Event:EndFirstStrike
			ExecWait $Script_ReturnHome_DarkCollective 
			Call     HPBarToHome 	( .Actor:Self )
		Case  ==  .Event:RecoverStatus
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimIdle 
			ExecWait DoRecover 
		Case  ==  .Event:ScareAway
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRun 
			SetConst  *Var[2]  .AnimPain 
			ExecWait DoScareAway 
			Return
		Case  ==  .Event:BeginAirLift
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRun 
			ExecWait DoAirLift 
		Case  ==  .Event:BlowAway
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRun 
			ExecWait DoBlowAway 
			Return
		Case  ==  .Event:UpAndAway
		Default
	EndSwitch
	Call     EnableIdleScript 	( .Actor:Self 00000001 )
	Call     UseIdleAnimation 	( .Actor:Self .True )
	Return
	End
}


%Copy from huff n puff's code
#new:IntTable $DarkFragmentIDs
{
	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
}


%you really don't want a lot of these guys floating around
#new:Script $Script_ShedDarkFragments
{
    0:  UseArray  $DarkFragmentIDs					%need this for later
    C:  Call  GetLastDamage ( .Actor:Self *Var9 )	
   20:  If  *Var9  <=  00000000
   30:  	Return									%so 0 damage does not summon any
   38:  EndIf
		/%											get rid of this, each hit spawns 1 regardless of damage or action commands
   40:  Call  GetBattleFlags    ( *Var0 )
   50:  If  *Var0  &  00000240
   60:  	If  *Var9  >  00000008
   70:  		Set   *Var9  00000008				%Cap to 8 tuff puffs spawned from a successful attack
   80:  	EndIf
   88:  Else
   90:  	If  *Var9  >  00000004
   A0:  		Set   *Var9  00000004				%Cap to 4 tuff puffs spawned from an unsuccessful attack
   B0:  	EndIf
   B8:  EndIf
		%/
		Set *Var9 1
   C0:  Call  GetLastEvent  ( .Actor:Self *Var0 )	%spawn nothing if you're dead
   D4:  Switch  *Var0
   E0:  	CaseOR  ==  .Event:Death % 20
   EC:  	CaseOR  ==  .Event:BurnDeath % 24
   F8:  		Return
  100:  	EndCaseGroup
  108:  EndSwitch
		/%															seems to control some size stuff
  110:  Call  GetActorVar   ( .Actor:Self 00000006 *Var0 )	%???
  128:  Call  GetLastDamage ( .Actor:Self *Var8 )
  13C:  Mul   *Var8  00000001
  14C:  Sub   *Var0  *Var8
  15C:  If  *Var0  <  00000032
  16C:  	Set   *Var0  00000032
  17C:  EndIf
  184:  Call  SetActorVar   ( .Actor:Self 00000006 *Var0 )
  19C:  Call  GetActorVar   ( .Actor:Self 00000007 *Var0 )
  1B4:  Call  GetLastDamage ( .Actor:Self *Var8 )
  1C8:  Mul   *Var8  00000001
  1D8:  Sub   *Var0  *Var8
  1E8:  If  *Var0  <  00000032
  1F8:  	Set   *Var0  00000032
  208:  EndIf
  210:  Call  SetActorVar       ( .Actor:Self 00000007 *Var0 )
  228:  ExecWait  $Script_80219CC0
		%/
  234:  Set   *VarA  00000000
  244:  Call  GetBattleFlags    ( *Var0 )
  254:  If  *Var0  &  00000240
  264:  	Set   *Var0  *Var9
  274:  	If  *Var0  >  00000001
  284:  		Set   *VarA  *Var0
  294:  		Div   *VarA  00000002
  2A4:  		Set   *Var9  *Var0
  2B4:  		Mod   *Var9  00000002
  2C4:  		Add   *Var9  *VarA
  2D4:  	EndIf
  2DC:  EndIf
  2E4:  Loop  *Var9					%Spawn this many of them
  2F0:  	Call  $Function_802185D4 ( )	%Rewrite the formation to change the position (what)
			/%
  2FC:  	If  *VarA  >  00000000
  30C:  		Sub   *VarA  00000001
  31C:  		Call  SummonEnemy   ( $SpecialFormation_8021A370 00000000 )
  330:  		Call  SetActorVar   ( *Var0 00000005 00000002 )
  348:  	Else
  350:  		Call  SummonEnemy   ( $SpecialFormation_8021A354 00000000 )
  364:  		Call  SetActorVar   ( *Var0 00000005 00000001 )
  37C:  	EndIf
			%/
			%Refresh IDs so that this guy can keep summoning instead of only being able to attack a max of 10 times
			Call  GetActorVar   ( .Actor:Self 00000002 *VarC )	%ActorVar 2 = open / filled slots
			Call  ActorExists   ( *Array[0] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFFE
			EndIf
			Call  ActorExists   ( *Array[1] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFFD
			EndIf
			Call  ActorExists   ( *Array[2] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFFB
			EndIf
			Call  ActorExists   ( *Array[3] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFF7
			EndIf
			Call  ActorExists   ( *Array[4] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFEF
			EndIf
			Call  ActorExists   ( *Array[5] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFDF
			EndIf
			Call  ActorExists   ( *Array[6] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFFBF
			EndIf
			Call  ActorExists   ( *Array[7] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFF7F
			EndIf
			Call  ActorExists   ( *Array[8] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFEFF
			EndIf
			Call  ActorExists   ( *Array[9] *Var1 )
			If  *Var1  ==  .True			
				ConstAND  *VarC  FFFFFDFF
			EndIf
			Call  SetActorVar   ( .Actor:Self 00000002 *VarC )	%ActorVar 2 = open / filled slots
			%Spawn the same size boo regardless
			Call  SummonEnemy   ( $SpecialFormation_DarkFragment 00000000 )
  384:  	Call  GetActorVar   ( .Actor:Self 00000002 *Var1 )	%ActorVar 2 = open / filled slots
  39C:  	Call  $Function_80218440    ( *Var1 *Var2 )			%find a random open slot 
  3B0:  	Switch  *Var2
  3BC:  		Case  ==  00000001
  3C8:  			ConstOR  *Var1 00000001
  3D8:  			Set   *Var2  00000000
  3E8:  			Set   *Array[0]  *Var0
  3F8:  		Case  ==  00000002
  404:  			ConstOR  *Var1 00000002
  414:  			Set   *Var2  00000001
  424:  			Set   *Array[1]  *Var0
  434:  		Case  ==  00000004
  440:  			ConstOR  *Var1 00000004
  450:  			Set   *Var2  00000002
  460:  			Set   *Array[2]  *Var0
  470:  		Case  ==  00000008
  47C:  			ConstOR  *Var1 00000008
  48C:  			Set   *Var2  00000003
  49C:  			Set   *Array[3]  *Var0
  4AC:  		Case  ==  00000010
  4B8:  			ConstOR  *Var1 00000010
  4C8:  			Set   *Var2  00000004
  4D8:  			Set   *Array[4]  *Var0
  4E8:  		Case  ==  00000020
  4F4:  			ConstOR  *Var1 00000020
  504:  			Set   *Var2  00000005
  514:  			Set   *Array[5]  *Var0
  524:  		Case  ==  00000040
  530:  			ConstOR  *Var1 00000040
  540:  			Set   *Var2  00000006
  550:  			Set   *Array[6]  *Var0
  560:  		Case  ==  00000080
  56C:  			ConstOR  *Var1 00000080
  57C:  			Set   *Var2  00000007
  58C:  			Set   *Array[7]  *Var0
  59C:  		Case  ==  00000100
  5A8:  			ConstOR  *Var1 00000100
  5B8:  			Set   *Var2  00000008
  5C8:  			Set   *Array[8]  *Var0
  5D8:  		Case  ==  00000200
  5E4:  			ConstOR  *Var1 00000200
  5F4:  			Set   *Var2  00000009
  604:  			Set   *Array[9]  *Var0
  614:  		Default
  61C:  			Set   *Var2  FFFFFFFF
  62C:  	EndSwitch
  634:  	Call  SetActorVar       ( .Actor:Self 00000002 *Var1 )
  64C:  	Call  PlaySoundAtActor  ( *Var0 .Sound:OpenShell )
  660:  	Thread
  668:  		Set   *Var3  *Var0
  678:  		Call  MakeLerp      ( 00000096 000000FF 0000000F .Easing:QuadraticIn )
  694:  		Label  7B
  6A0:  		Call  UpdateLerp ( )
  6AC:  		Call  SetPartAlpha  ( *Var3 00000001 *Var0 )
  6C4:  		Wait  1`
  6D0:  		If  *Var1  ==  00000001
  6E0:  			Goto  7B
  6EC:  		EndIf
  6F4:  		Call  SetPartAlpha  ( *Var3 00000001 000000FF )
  70C:  	EndThread
  714:  	If  *Var2  !=  FFFFFFFF
  724:  		Call  CopyStatusEffects     ( .Actor:Self *Var0 )
  738:  		Call  CopyBuffs     ( .Actor:Self *Var0 )
  74C:  		Call  SetActorVar   ( *Var0 00000001 *Var2 )
  764:  		Call  GetActorPos   ( .Actor:Self *Var3 *Var4 *Var5 )
  780:  		Call  SetActorPos   ( *Var0 *Var3 *Var4 *Var5 )
  79C:  		Add   *Var3  FFFFFFFB
  7AC:  		Add   *Var4  30`		%need to offset this
  7BC:  		Add   *Var5  00000000
  7CC:  		Mul   *Var2  00000024
  7DC:  		Add   *Var2  00000000
  7EC:  		Call  $Function_802182A4    ( *Var3 *Var4 *Var5 *Var2 *Fixed[0.0] *Fixed[50.0] )	%Find a point 50 away from the target
  810:  		Thread
  818:  			Call  SetActorJumpGravity   ( *Var0 *Fixed[0.8] )
  82C:  			Call  SetGoalPos    ( *Var0 *Var3 *Var4 *Var5 )
  848:  			Call  JumpToGoal    ( *Var0 0000001E .False .False .False )
  868:  			Call  ForceHomePos  ( *Var0 *Var3 *Var4 *Var5 )
  884:  			Call  HPBarToHome   ( *Var0 )
  894:  		EndThread
  89C:  	Else
  8A4:  		Call  GetActorPos   ( .Actor:Self *Var3 *Var4 *Var5 )
  8C0:  		Call  SetActorPos   ( *Var0 *Var3 *Var4 *Var5 )
  8DC:  		Call  RandInt       ( 000000C8 *Var6 )
  8F0:  		Sub   *Var6  00000064
  900:  		Add   *Var3  *Var6
  910:  		Add   *Var5  0000000A
  920:  		Thread
  928:  			Call  SetActorJumpGravity   ( *Var0 *Fixed[0.8] )
  93C:  			Call  SetGoalPos    ( *Var0 *Var3 FFFFFFE2 *Var5 )
  958:  			Call  JumpToGoal    ( *Var0 00000028 .False .False .False )
  978:  			Call  RemoveActor   ( *Var0 )
  988:  		EndThread
  990:  	EndIf
  998:  EndLoop
  9A0:  Return
  9A8:  End
}

%Original version altered both tuff puff formations
#new:Function $Function_802185D4
{
    0:  ADDIU     SP, SP, FFE8
    4:  SW        S0, 10 (SP)
    8:  COPY      S0, A0
    C:  SW        RA, 14 (SP)
   10:  JAL       ~Func:get_actor
   14:  LW        A0, 148 (S0)
   18:  LB        V0, 1F1 (V0)
   1C:  SAW       V0, $SpecialFormation_DarkFragment[8]
   24:  JAL       ~Func:get_actor
   28:  LW        A0, 148 (S0)
   2C:  LB        V1, 1F1 (V0)
   30:  LW        RA, 14 (SP)
   34:  LW        S0, 10 (SP)
   38:  LI        V0, 2
   3C:  SAW       V1, $SpecialFormation_DarkFragment[8]
   44:  JR        RA
   48:  ADDIU     SP, SP, 18
}

#new:Function $Function_802182A4
{
    0:  ADDIU     SP, SP, FFA0
    4:  SW        S1, 1C (SP)
    8:  COPY      S1, A0
    C:  SW        RA, 2C (SP)
   10:  SW        S4, 28 (SP)
   14:  SW        S3, 24 (SP)
   18:  SW        S2, 20 (SP)
   1C:  SW        S0, 18 (SP)
   20:  SDC1      F30, 58 (SP)
   24:  SDC1      F28, 50 (SP)
   28:  SDC1      F26, 48 (SP)
   2C:  SDC1      F24, 40 (SP)
   30:  SDC1      F22, 38 (SP)
   34:  SDC1      F20, 30 (SP)
   38:  LW        S0, C (S1)
   3C:  LW        S3, 0 (S0)
   40:  ADDIU     S0, S0, 4
   44:  JAL       ~Func:get_float_variable
   48:  COPY      A1, S3
   4C:  SWC1      F0, 10 (SP)
   50:  LW        S4, 0 (S0)
   54:  ADDIU     S0, S0, 4
   58:  COPY      A0, S1
   5C:  JAL       ~Func:get_float_variable
   60:  COPY      A1, S4
   64:  MOV.S     F30, F0
   68:  LW        S2, 0 (S0)
   6C:  ADDIU     S0, S0, 4
   70:  COPY      A0, S1
   74:  JAL       ~Func:get_float_variable
   78:  COPY      A1, S2
   7C:  MOV.S     F28, F0
   80:  LW        A1, 0 (S0)
   84:  ADDIU     S0, S0, 4
   88:  JAL       ~Func:get_float_variable
   8C:  COPY      A0, S1
   90:  LW        A1, 0 (S0)
   94:  ADDIU     S0, S0, 4
   98:  COPY      A0, S1
   9C:  JAL       ~Func:get_float_variable
   A0:  MOV.S     F26, F0
   A4:  MOV.S     F24, F0
   A8:  LW        A1, 0 (S0)
   AC:  JAL       ~Func:get_float_variable
   B0:  COPY      A0, S1
   B4:  MOV.S     F12, F26
   B8:  LIF       F2, 15.0
   C0:  MOV.S     F22, F0
   C4:  JAL       ~Func:cos_deg
   C8:  SUB.S     F24, F24, F2
   CC:  MOV.S     F20, F0
   D0:  JAL       ~Func:cos_deg
   D4:  MOV.S     F12, F24
   D8:  MUL.S     F20, F22, F20
   DC:  NOP
   E0:  MUL.S     F20, F20, F0
   E4:  NOP
   E8:  LWC1      F4, 10 (SP)
   EC:  ADD.S     F4, F4, F20
   F0:  MOV.S     F12, F26
   F4:  JAL       ~Func:sin_deg
   F8:  SWC1      F4, 10 (SP)
   FC:  MUL.S     F0, F22, F0
  100:  NOP
  104:  MOV.S     F12, F26
  108:  JAL       ~Func:cos_deg
  10C:  ADD.S     F30, F30, F0
  110:  MOV.S     F12, F24
  114:  JAL       ~Func:sin_deg
  118:  MOV.S     F20, F0
  11C:  MUL.S     F22, F22, F20
  120:  NOP
  124:  MUL.S     F22, F22, F0
  128:  NOP
  12C:  COPY      A0, S1
  130:  COPY      A1, S3
  134:  LW        A2, 10 (SP)
  138:  JAL       ~Func:set_float_variable
  13C:  SUB.S     F28, F28, F22
  140:  COPY      A0, S1
  144:  MFC1      A2, F30
  148:  JAL       ~Func:set_float_variable
  14C:  COPY      A1, S4
  150:  COPY      A0, S1
  154:  MFC1      A2, F28
  158:  JAL       ~Func:set_float_variable
  15C:  COPY      A1, S2
  160:  LW        RA, 2C (SP)
  164:  LW        S4, 28 (SP)
  168:  LW        S3, 24 (SP)
  16C:  LW        S2, 20 (SP)
  170:  LW        S1, 1C (SP)
  174:  LW        S0, 18 (SP)
  178:  LDC1      F30, 58 (SP)
  17C:  LDC1      F28, 50 (SP)
  180:  LDC1      F26, 48 (SP)
  184:  LDC1      F24, 40 (SP)
  188:  LDC1      F22, 38 (SP)
  18C:  LDC1      F20, 30 (SP)
  190:  LI        V0, 2
  194:  JR        RA
  198:  ADDIU     SP, SP, 60
}

#new:SpecialFormation $SpecialFormation_DarkFragment
{
	$DarkFragment $Vector3D_Negative 00000000 00000000 00000000 00000000 00000000
}

#new:Vector3D $Vector3D_Negative
{
	0` -1000` 0`
}

#new:Function $Function_80218440
{
    0:  ADDIU     SP, SP, FFB8
    4:  SW        S1, 3C (SP)
    8:  COPY      S1, A0
    C:  SW        RA, 40 (SP)
   10:  SW        S0, 38 (SP)
   14:  LW        S0, C (S1)
   18:  LW        A1, 0 (S0)
   1C:  JAL       ~Func:get_variable
   20:  ADDIU     S0, S0, 4
   24:  COPY      A1, V0
   28:  ANDI      V0, A1, 2
   2C:  BNE       V0, R0, .o40
   30:  CLEAR     A0
   34:  LI        V0, 2
   38:  SW        V0, 10 (SP)
   3C:  LI        A0, 1
        .o40
   40:  ANDI      V0, A1, 8
   44:  BNE       V0, R0, .o64
   48:  ANDI      V0, A1, 20
   4C:  SLL       V0, A0, 2
   50:  ADDU      V1, SP, V0
   54:  LI        V0, 8
   58:  SW        V0, 10 (V1)
   5C:  ADDIU     A0, A0, 1
   60:  ANDI      V0, A1, 20
        .o64
   64:  BNE       V0, R0, .o84
   68:  ANDI      V0, A1, 80
   6C:  SLL       V0, A0, 2
   70:  ADDU      V1, SP, V0
   74:  LI        V0, 20
   78:  SW        V0, 10 (V1)
   7C:  ADDIU     A0, A0, 1
   80:  ANDI      V0, A1, 80
        .o84
   84:  BNE       V0, R0, .oA4
   88:  ANDI      V0, A1, 200
   8C:  SLL       V0, A0, 2
   90:  ADDU      V1, SP, V0
   94:  LI        V0, 80
   98:  SW        V0, 10 (V1)
   9C:  ADDIU     A0, A0, 1
   A0:  ANDI      V0, A1, 200
        .oA4
   A4:  BNE       V0, R0, .oC4
   A8:  ANDI      V0, A1, 1
   AC:  SLL       V0, A0, 2
   B0:  ADDU      V1, SP, V0
   B4:  LI        V0, 200
   B8:  SW        V0, 10 (V1)
   BC:  ADDIU     A0, A0, 1
   C0:  ANDI      V0, A1, 1
        .oC4
   C4:  BNE       V0, R0, .oE4
   C8:  ANDI      V0, A1, 4
   CC:  SLL       V0, A0, 2
   D0:  ADDU      V1, SP, V0
   D4:  LI        V0, 1
   D8:  SW        V0, 10 (V1)
   DC:  ADDU      A0, A0, V0
   E0:  ANDI      V0, A1, 4
        .oE4
   E4:  BNE       V0, R0, .o104
   E8:  ANDI      V0, A1, 10
   EC:  SLL       V0, A0, 2
   F0:  ADDU      V1, SP, V0
   F4:  LI        V0, 4
   F8:  SW        V0, 10 (V1)
   FC:  ADDIU     A0, A0, 1
  100:  ANDI      V0, A1, 10
        .o104
  104:  BNE       V0, R0, .o11C
  108:  SLL       V0, A0, 2
  10C:  ADDU      V1, SP, V0
  110:  LI        V0, 10
  114:  SW        V0, 10 (V1)
  118:  ADDIU     A0, A0, 1
        .o11C
  11C:  BNE       A0, R0, .o15C
  120:  ANDI      V0, A1, 100
  124:  BNE       V0, R0, .o13C
  128:  ANDI      V0, A1, 40
  12C:  LI        V0, 100
  130:  SW        V0, 10 (SP)
  134:  LI        A0, 1
  138:  ANDI      V0, A1, 40
        .o13C
  13C:  BNE       V0, R0, .o154
  140:  SLL       V0, A0, 2
  144:  ADDU      V1, SP, V0
  148:  LI        V0, 40
  14C:  SW        V0, 10 (V1)
  150:  ADDIU     A0, A0, 1
        .o154
  154:  BEQ       A0, R0, .o170
  158:  LI        A2, FFFF
        .o15C
  15C:  JAL       ~Func:rand_int
  160:  ADDIU     A0, A0, FFFF
  164:  SLL       V0, V0, 2
  168:  ADDU      V0, SP, V0
  16C:  LW        A2, 10 (V0)
        .o170
  170:  LW        A1, 0 (S0)
  174:  JAL       ~Func:set_variable
  178:  COPY      A0, S1
  17C:  LW        RA, 40 (SP)
  180:  LW        S1, 3C (SP)
  184:  LW        S0, 38 (SP)
  188:  LI        V0, 2
  18C:  JR        RA
  190:  ADDIU     SP, SP, 48
}


%he never attacks, but he slowly increases his power over time
%	but you still have to deal with the dark fragments that come from him 
%	Wacky boss design
%	Just kidding, he actually attacks in order to negate certain strategies I don't like

#new:Script $Script_TakeTurn_DarkCollective
{
	ExecWait $Script_CollectiveWave
	Thread
		Call  8026BF48      ( 00000001 )
		Call  BoostAttack   ( .Actor:Self 00000001 )	
		Call  8026BF48      ( 00000000 )
	EndThread
	Wait 30`
	Return
	End
}

#define .voffset 50`

%5 if visible, 25 if invisible!
#new:Script $Script_CollectiveWave
{
	%monstar attack
	Call     UseBattleCamPreset 	( 00000013 )
	Call     GetActorPos 	( .Actor:Self *Var[0] *Var[1] *Var[2] )
	Add *Var1 .voffset
	Call     SetBattleCamTarget 	( *Var[0] *Var[1] *Var[2] )
	Call     SetBattleCamOffsetZ 	( 00000010 )
	Call     BattleCamTargetActor ( .Actor:Self )
	Call     MoveBattleCamOver 	( 0000001E )
	Wait 0000001E 
	%Thread
	%	Call     $Function_80218458_DG ( )
	%	Call     MakeLerp    	( 00000000 000000C8 0000003C 00000001 )
	%	Label    00000000 
	%	Call     UpdateLerp  	( )
	%	Call     $Function_8021849C_DG ( *Var[0] )
	% 	Wait     00000001 
	%	If  *Var[1]  ==  00000001 
	%		Goto     00000000 
	%	EndIf
	%EndThread
	%Call     PlaySoundAtActor 	( .Actor:Self .Sound:BigPowerUp )
	%Call     $Function_802184D4_DG ( 00000050 00000078 )
	%Call     UseBattleCamPreset 	( 00000013 )
	%Call     GetActorPos 	( .Actor:Self *Var[0] *Var[1] *Var[2] )
	%Add *Var1 .voffset
	%Call     SetBattleCamTarget 	( *Var[0] *Var[1] *Var[2] )
	%Call     SetBattleCamZoom  	( 00000064 )
	%Call     SetBattleCamOffsetZ 	( 00000020 )
	%Call     BattleCamTargetActor ( .Actor:Self )
	%Call     MoveBattleCamOver 	( 0000003C )
	%Wait     0000003C 
	Call     PlaySoundAtActor 	( .Actor:Self 000002EA )
	Call     PlaySoundAtActor 	( .Actor:Self 0000036E )
	Thread
		Wait     0000000A 
		Loop     00000012 
			Call     RandInt     	( 00000096 *Var[0] )
			Add  *Var[0]  00000064 
			Call     $Function_802184D4_DG ( *Var[0] 00000014 )
			Wait     0000000A 
		EndLoop
	EndThread
	Wait     00000008 
	Call     UseBattleCamPreset 	( 00000002 )
	Call     MoveBattleCamOver 	( 0000000A )
	Call     GetActorPos 	( .Actor:Self *Var[0] *Var[1] *Var[2] )
	Add *Var1 .voffset
	Call     PlayEffect  	( ~FX:RadialFlowOut:BlueSpikes *Var[0] *Var[1] *Var[2] *Fixed[0.80078125] 00000050 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
	Call	 $Function_SetRadialPalette_Col ( *VarF )
	%Call     SetAnimation 	( .Actor:Self 00000001 0062050D )
	%this is not a real attack (on you) so do not check hit
	Wait     0000005A %90 frames (was 170)
	Wait     00000002 
	Call     SetGoalToTarget 	( .Actor:Self )
	%Do damage
	Call     EnemyTestTarget ( .Actor:Self *Var[0] 00000000 00000000 00000001 00000010 )
	Switch *Var0
		Case == 6`
			Call     EnemyDamageTarget 	( .Actor:Self *Var[0] 10000000 00000000 00000000 00000014 00000020 )
		Default
			Call     EnemyDamageTarget 	( .Actor:Self *Var[0] 10000000 00000000 00000000 00000005 00000020 )
	EndSwitch
	%Call     SetAnimation 	( .Actor:Self 00000001 00620502 )
	%Call     SetIdleAnimations 	( .Actor:Self 00000001 $IdleAnimations_DarkGoomba )
	Call     MakeLerp    	( 000000C8 00000000 0000003C 00000000 )
	Label    00000002 
	Call     UpdateLerp  	( )
	Call     $Function_8021849C_DG ( *Var[0] )
	Wait     00000001 
	If  *Var[1]  ==  00000001 
		Goto     00000002 
	EndIf
	Wait     00000014 
	Return
	End
}

%lightning effect color swapping
%This effect color is counterintuitive
#new:Function $Function_SetRadialPalette_Col
{
		PUSH		RA, S0
    8:  LW			V0, C (A0)
    C:  JAL			~Func:get_variable
   10:  LW			A1, 0 (V0)
   14:  LW			V1, C (V0)
   18:  ADDIU		A1, R0, 0000		%R + G
   1C:  SH			A1, 68 (V1)
   20:  LW			V1, C (V0)
   18:  ADDIU		A1, R0, 00FF		%B + R2?
   24:  SH			A1, 6A (V1)
   28:  LW			V1, C (V0)
   18:  ADDIU		A1, R0, FF00		%G2 + B2?
   2C:  SH			A1, 6C (V1)
   30:  LW			A0, C (V0)
   34:  ADDIU		V1, R0, 0000		%supplemental data
   38:  SH			V1, 6E (A0)
		.end
   54:  ADDIU		V0, R0, 2
		JPOP		RA, S0
}

#new:Function $Function_80218458_DG
{
    0:  ADDIU     SP, SP, FFE8
    4:  SW        RA, 10 (SP)
    8:  JAL       8011D82C
    C:  ADDIU     A0, R0, 1
   10:  DADDU     A0, R0, R0
   14:  ADDIU     V0, R0, 1
   18:  DADDU     A1, A0, R0
   1C:  DADDU     A2, A0, R0
   20:  LAW       V1, 801512F0
   28:  DADDU     A3, A0, R0
   2C:  JAL       8011BE5C
   30:  SB        V0, 0 (V1)
   34:  LW        RA, 10 (SP)
   38:  ADDIU     V0, R0, 2
   3C:  JR        RA
   40:  ADDIU     SP, SP, 18
}

#new:Function $Function_8021849C_DG
{
    0:  ADDIU     SP, SP, FFE8
    4:  SW        RA, 10 (SP)
    8:  LW        V0, C (A0)
    C:  JAL       ~Func:get_variable
   10:  LW        A1, 0 (V0)
   14:  DADDU     A0, R0, R0
   18:  DADDU     A1, A0, R0
   1C:  DADDU     A2, A0, R0
   20:  JAL       8011BE5C
   24:  ANDI      A3, V0, FF
   28:  LW        RA, 10 (SP)
   2C:  ADDIU     V0, R0, 2
   30:  JR        RA
   34:  ADDIU     SP, SP, 18
}

#new:Function $Function_802184D4_DG
{
    0:  ADDIU     SP, SP, FFE0
    4:  SW        S1, 14 (SP)
    8:  DADDU     S1, A0, R0
    C:  SW        RA, 18 (SP)
   10:  SW        S0, 10 (SP)
   14:  LW        S0, C (S1)
   18:  LW        A1, 0 (S0)
   1C:  JAL       ~Func:get_variable
   20:  ADDIU     S0, S0, 4
   24:  DADDU     A0, S1, R0
   28:  LW        A1, 0 (S0)
   2C:  JAL       ~Func:get_variable
   30:  DADDU     S0, V0, R0
   34:  DADDU     A0, S0, R0
   38:  JAL       80028F08
   3C:  DADDU     A1, V0, R0
   40:  LW        RA, 18 (SP)
   44:  LW        S1, 14 (SP)
   48:  LW        S0, 10 (SP)
   4C:  ADDIU     V0, R0, 2
   50:  JR        RA
   54:  ADDIU     SP, SP, 20
}

/%
#new:Vector3D $BooPos %position is no longer hardcoded, so I don't have to recalculate this every time I move atomic boo around
{
0` -1000` 0` %45` 65` 15`
}

%delta vector: -5, 45, 15

#new:SpecialFormation $BooFormation
{
$SkyBoo	$BooPos 00000009 00000000 00000000 00000000 00000000 
}

#new:Script $Script_DarkFragmentCannon	
{
	Call     SetTargetActor ( .Actor:Self .Actor:Player )
	Call     UseIdleAnimation 	( .Actor:Self .False )
    Call     EnableIdleScript 	( .Actor:Self 00000000 )
	Call     SetAnimation 		( .Actor:Self 00000001 00EF0501 )
	Set *Flag[01] 1 %flag for entering state 2
	Call	GetPlayerHP ( *Var[F] )
	Loop 4`
	Thread
	Call     SummonEnemy		( $BooFormation 00000000 )
	Set *Var[1] *Var[0]
	Call	 GetActorPos		( .Actor:Self *Var[A] *Var[B] *Var[C] )
	Sub *Var[A] 5`
	Add *Var[B] 45`
	Add *Var[C] 15`
	Call	 SetActorPos 		( *Var[1] *Var[A] *Var[B] *Var[C] )
	Call     UseIdleAnimation 	( *Var[1] .False )
    Call     EnableIdleScript 	( *Var[1] 00000000 )
	%Call     SetAnimation 		( *Var[1] 00000001 006B0819 )
	Call	 SetAnimation 		( *Var[1] 00000001 00F00506 )
	Call     SetTargetActor ( *Var[1] .Actor:Player )
	Call     SetGoalToTarget 	( *Var[1] )
	Call     SetActorSpeed     	( *Var[1] *Fixed[18.0] ) %12 -> 18
	Call     JumpToGoal      	( *Var[1] 0000000E 00000000 00000001 00000000 ) %14 (dec 20) -> E (dec 14)
	Wait 	 2`
	Call	EnemyTestTarget ( .Actor:Self  *Var[5] 00000000 00000000 00000001 00000010 )
	Switch  *Var[5] 
    	CaseOR  ==  00000006 
    	CaseOR  ==  00000005 % lucky, transparent
		Set *Flag[01] 0
		Goto 00000001
	EndSwitch
		Call     EnemyDamageTarget 	( *Var[1] *Var[8] 10000000 00000000 00000000 00000003 00000020 ) %3 each
	Wait     1`
	% Go off-screen
	Label 00000001
	Call     SetGoalPos		( *Var[1] -300` 0` 0` )
	Call     SetActorJumpGravity 	( *Var[1] *Fixed[1.0] )
	Call     JumpToGoal    		( *Var[1] 0000000E 00000000 00000001 00000000 ) %14 (dec 20) -> E (dec 14)
	Wait     4
	Call     RemoveActor 	( *Var[1] )
	EndThread
	Thread
	Wait 	 10`
	Call     SummonEnemy		( $BooFormation 00000000 )
	Call     UseIdleAnimation 	( *Var[0] .False )
    Call     EnableIdleScript 	( *Var[0] 00000000 )
	%Call     SetAnimation 		( *Var[1] 00000001 006B0819 )
	Call	 SetAnimation 		( *Var[1] 00000001 00F00506 )
	Call     SetTargetActor ( *Var[0] .Actor:Player )
	Call     SetGoalToTarget 	( *Var[0] )
	Call     SetActorSpeed     	( *Var[0] *Fixed[30.0] ) %20 -> 30
	Call     JumpToGoal      	( *Var[0] 0000000E 00000000 00000001 00000000 ) %14 (dec 20) -> E (dec 14)
	Wait 	 2`
	Call	EnemyTestTarget ( .Actor:Self  *Var[5] 00000000 00000000 00000001 00000010 )
	Switch  *Var[5] 
    	CaseOR  ==  00000006 
    	CaseOR  ==  00000005 % lucky, transparent
		Set *Flag[01] 0
		Goto 00000001
	EndSwitch
		Call     EnemyDamageTarget 	( *Var[0] *Var[8] 00000000 00000000 00000000 00000003 00000020 )
	Wait     1`
	% Go off-screen
	Label 00000001
	Call     SetGoalPos		( *Var[0] -300` 0` 0` )
	Call     SetActorJumpGravity 	( *Var[0] *Fixed[1.0] )
	Call     JumpToGoal    		( *Var[0] 0000000E 00000000 00000001 00000000 ) %14 (dec 20) -> E (dec 14)
	Wait     4
	Call     RemoveActor 	( *Var[0] )
	EndThread
	Wait 28` 
	EndLoop
	Call	GetPlayerHP ( *Var[E] )
	Sub *Var[F] *Var[E] %find HP difference
	If *Var[F] < 4 %took less than 4 damage
		If *Flag[01] == 00000001
			Call SetActorVar (.Actor:Self 00000003 00000002 )
		EndIf
	EndIf
	Call     UseIdleAnimation 	( .Actor:Self .True )
    Call     EnableIdleScript 	( .Actor:Self 00000001 )
	Return
	End
}
%/

#new:Actor $DarkFragment
{
% stats
[Index]        C4b 
[Level]         0`b 
[MaxHP]         1`b 
[Coins]         2`b 
[Flags]       00000200 
[StatusTable] $StatusTable_DarkCollective
% ai
[PartsCount]   1`s 
[PartsTable] $PartsTable_DarkFragment 
[Script]      $Script_Init_DarkFragment 
% move effectiveness
[Escape]        0`b 
[Item]          0`b 
[AirLift]       0`b 
[Hurricane]     0`b % Bow's "Sp
[SpinSmash]     0`b % weight (0-4)
% ui positions
[Size]         20`b  20`b % width height
[HealthBar]     0`b   0`b % dx dyook" as well
[UpAndAway]    95`b 
[PowerBounce]  3`b 
[StatusTurn]  -10`b  20`b % dx dy
[StatusIcon]   10`b  20`b % dx dy
}

#new:PartsTable $PartsTable_DarkFragment
{
00800000 01000000 001400FF $IdleAnimations_DarkFragment $DefenseTable_DarkCollective 00000000 00000000 00F60000 00000000 
}

#new:IdleAnimations $IdleAnimations_DarkFragment
{
.Status:Normal    .AnimIdleDB
.Status:Stone     .AnimStopDB
.Status:Sleep     .AnimSleepDB
.Status:Poison    .AnimIdleDB
.Status:Stop      .AnimStopDB
.Status:Static    .AnimIdleDB
.Status:Paralyze  .AnimStopDB
.Status:Dizzy     .AnimDizzyDB
.Status:End
}

#new:Function $Function_Vanish % ( duration )
{
	ADDIU	SP, SP, FFE0
	SW		RA, 10 (SP)
	SW		S1, 14 (SP)
	SW		S2, 18 (SP)
	% get turn count
	LW		A1, 0 (S0)
	JAL		~Func:get_variable
	DADDU	S1, A0, R0
	ANDI	V0, V0, 00FF
	% add electify status
	LW		A0, 148 (S1)
	JAL		~Func:get_actor
	DADDU	S2, V0, R0
	ORI		S2, S2, 0E00
	SH		S2, 218 (V0)
	% return
	LW		RA, 10 (SP)
	LW		S1, 14 (SP)
	LW		S2, 18 (SP)
	ADDIU	V0, R0, 2
	JR		RA
	ADDIU SP, SP, 20 
}

#new:Script $Script_Init_DarkFragment
{
	Call 	$Function_Vanish ( 1 )
	Call	BindTakeTurn	( .Actor:Self $Script_TakeTurn_DarkFragment )
	Call	BindIdle		( .Actor:Self $Script_Idle_DarkFragment )
	Call	BindHandleEvent	( .Actor:Self $Script_HandleEvent_DarkFragment )	%will cause problems if you actually hit them
	Return
	End
}
	
#new:Script $Script_Idle_DarkFragment
{
Return
End
}

#new:Script $Script_TakeTurn_DarkFragment
{
Call	 UseIdleAnimation ( .Actor:Self .False )
Call	 EnableIdleScript ( .Actor:Self .False )
Call     SetTargetActor 	( .Actor:Self .Actor:Player )
Call     SetGoalToTarget 	( .Actor:Self )
Call     SetActorSpeed 	( .Actor:Self *Fixed[12.0] )
Call     FlyToGoal  	( .Actor:Self 00000000 FFFFFFFC .Easing:CosInOut )
Call     EnemyTestTarget ( .Actor:Self *Var[0] 18000000 00000000 00000001 00000010 )
Set 	 *Var0 0		%No miss!
Switch  *Var[0] 
	CaseOR  ==  00000006 
	CaseOR  ==  00000005 
		%fly past
		If  *Var[A]  ==  00000005 
			Call     EnemyTestTarget ( .Actor:Self *Var[0] 80000000 00000000 00000000 00000000 )
		EndIf
		Call	 AddGoalPos		( .Actor:Self -50` 0` 0` )
		Call     SetActorSpeed 	( .Actor:Self *Fixed[15.0] )
		Call     FlyToGoal  	( .Actor:Self 00000000 FFFFFFFC .Easing:Linear )
		Goto 0
	EndCaseGroup
EndSwitch
%deal damage
Call     EnemyDamageTarget 	( .Actor:Self *Var[0] 18000000 0000FFFF 00000000 00000005 00000020 ) 
Label    0
Call	 ActorExists ( .Actor:Enemy0 *Var0 )
If *Var0 == 1
	Call	 YieldTurn 		( )
	ExecWait $Script_FlyToDarkCollective   
Else
	SetConst  *Var[0]  00000001 
	SetConst  *Var[1]  .AnimPainDB 
	ExecWait DoDeath	%die instead of trying to heal
EndIf
Return
End
}

#new:Script $Script_FlyToDarkCollective
{
%this is probably fine since all the dark fragments will die on the same turn since you can never stun them
Call  	 SetActorVar       ( .Actor:Self 00000002 00000000 )
Call	 GetActorPos 	( .Actor:Enemy0 *Var0 *Var1 *Var2 )
Add 	 *Var1 30`	%Need to offset this position
Call	 SetGoalPos		( .Actor:Self *Var0 *Var1 *Var2 )
Call	 SetActorRotation ( .Actor:Self 0` 180` 0` )
Call     SetActorSpeed 	( .Actor:Self *Fixed[15.0] )
Call     FlyToGoal  	( .Actor:Self 00000000 FFFFFFFC .Easing:CosIn )
%Healing time
Set *Var3 4
Call     GetActorPos 	( .Actor:Enemy0 *Var[0] *Var[1] *Var[2] )
Add 	 *Var1 30`		%Need to offset this position
Call     PlayEffect  	( ~FX:Sparkles:Star *Var[0] *Var[1] *Var[2] *Fixed[1.0] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
Add  *Var[0]  00000014 
Call     PlayEffect  	( ~FX:Recover:HP *Var[0] *Var[1] *Var[2] *Var[3] 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 )
Call     GetActorHP  	( .Actor:Enemy0 *Var[0] )
Add  *Var[0]  *Var[3] 
Call     GetEnemyMaxHP 	( .Actor:Enemy0 *Var[1] )
If  *Var[0]  >  *Var[1] 
	Set  *Var[0]  *Var[1] 
EndIf
Call     SetEnemyHP  	( .Actor:Enemy0 *Var[0] )
Call	 RemoveActor	( .Actor:Self )
Return
End
}

#define .AnimStopDB	00F00500
#define .AnimIdleDB	00F00501
#define .AnimRunDB	00F00503
#define .AnimPainDB	00F00506
#define .AnimHideDB	00F00507
#define .AnimSpookDB	00F00508
#define .AnimDizzyDB	00F00509
#define .AnimDeadDB	00F00512 %unused?
#define .AnimSleepDB  00F00512 %new (but it's literally just a still frame)

#new:Script $Script_HandleEvent_DarkFragment
{
	Call     UseIdleAnimation 	( .Actor:Self .False )
	Call     EnableIdleScript 	( .Actor:Self 00000000 )
	Call     GetLastEvent 	( .Actor:Self *Var[0] )
	Switch  *Var[0] 
		CaseOR  ==  .Event:HitCombo
		CaseOR  ==  .Event:Hit
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoNormalHit 
		EndCaseGroup
		Case  ==  .Event:BurnHit
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			SetConst  *Var[2]  .AnimDeadDB 
			ExecWait DoBurnHit 
		Case  ==  .Event:BurnDeath
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			SetConst  *Var[2]  .AnimDeadDB 
			ExecWait DoBurnHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimDeadDB 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:SpinSmashHit
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait 8029B998 
		Case  ==  .Event:SpinSmashDeath
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait 8029B998 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:ShockHit
			Call     PlaySoundAtActor 	( .Actor:Self 00000759 )
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoShockHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait 8029BD70 
			ExecWait $Script_FlyToDarkCollective
		Case  ==  .Event:ShockDeath
			Call     PlaySoundAtActor 	( .Actor:Self 00000759 )
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoShockHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoDeath 
			Return
		CaseOR  ==  00000017
		CaseOR  ==  .Event:Immune
		CaseOR  ==  .Event:AirLiftFailed
		CaseOR  ==  .Event:BurnTaunt
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimIdleDB 
			ExecWait DoImmune 
		EndCaseGroup
		Case  ==  .Event:Death
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoNormalHit 
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimPainDB 
			ExecWait DoDeath 
			Return
		Case  ==  .Event:BeginFirstStrike
			Call     SetActorPos 	( .Actor:Self 00000014 00000000 00000000 )
			Call     HPBarToCurrent ( .Actor:Self )
		Case  ==  .Event:EndFirstStrike
			ExecWait $Script_FlyToDarkCollective
			Call     HPBarToHome 	( .Actor:Self )
		Case  ==  .Event:RecoverStatus
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimIdleDB 
			ExecWait DoRecover 
		Case  ==  .Event:ScareAway
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRunDB 
			SetConst  *Var[2]  .AnimPainDB 
			ExecWait DoScareAway 
			Return
		Case  ==  .Event:BeginAirLift
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRunDB 
			ExecWait DoAirLift 
		Case  ==  .Event:BlowAway
			SetConst  *Var[0]  00000001 
			SetConst  *Var[1]  .AnimRunDB 
			ExecWait DoBlowAway 
			Return
		Case  ==  .Event:UpAndAway
		Default
	EndSwitch
	Call     EnableIdleScript 	( .Actor:Self 00000001 )
	Call     UseIdleAnimation 	( .Actor:Self .True )
	Return
	End
}

